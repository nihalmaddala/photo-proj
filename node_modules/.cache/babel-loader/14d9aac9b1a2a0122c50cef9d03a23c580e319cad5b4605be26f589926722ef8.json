{"ast":null,"code":"import { ContentFilterFinishReasonError, LengthFinishReasonError, OpenAIError } from \"../error.mjs\";\nexport function isChatCompletionFunctionTool(tool) {\n  return tool !== undefined && 'function' in tool && tool.function !== undefined;\n}\nexport function makeParseableResponseFormat(response_format, parser) {\n  const obj = {\n    ...response_format\n  };\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-response-format',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nexport function makeParseableTextFormat(response_format, parser) {\n  const obj = {\n    ...response_format\n  };\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-response-format',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nexport function isAutoParsableResponseFormat(response_format) {\n  return response_format?.['$brand'] === 'auto-parseable-response-format';\n}\nexport function makeParseableTool(tool, {\n  parser,\n  callback\n}) {\n  const obj = {\n    ...tool\n  };\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-tool',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    },\n    $callback: {\n      value: callback,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nexport function isAutoParsableTool(tool) {\n  return tool?.['$brand'] === 'auto-parseable-tool';\n}\nexport function maybeParseChatCompletion(completion, params) {\n  if (!params || !hasAutoParseableInput(params)) {\n    return {\n      ...completion,\n      choices: completion.choices.map(choice => {\n        assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);\n        return {\n          ...choice,\n          message: {\n            ...choice.message,\n            parsed: null,\n            ...(choice.message.tool_calls ? {\n              tool_calls: choice.message.tool_calls\n            } : undefined)\n          }\n        };\n      })\n    };\n  }\n  return parseChatCompletion(completion, params);\n}\nexport function parseChatCompletion(completion, params) {\n  const choices = completion.choices.map(choice => {\n    if (choice.finish_reason === 'length') {\n      throw new LengthFinishReasonError();\n    }\n    if (choice.finish_reason === 'content_filter') {\n      throw new ContentFilterFinishReasonError();\n    }\n    assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);\n    return {\n      ...choice,\n      message: {\n        ...choice.message,\n        ...(choice.message.tool_calls ? {\n          tool_calls: choice.message.tool_calls?.map(toolCall => parseToolCall(params, toolCall)) ?? undefined\n        } : undefined),\n        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null\n      }\n    };\n  });\n  return {\n    ...completion,\n    choices\n  };\n}\nfunction parseResponseFormat(params, content) {\n  if (params.response_format?.type !== 'json_schema') {\n    return null;\n  }\n  if (params.response_format?.type === 'json_schema') {\n    if ('$parseRaw' in params.response_format) {\n      const response_format = params.response_format;\n      return response_format.$parseRaw(content);\n    }\n    return JSON.parse(content);\n  }\n  return null;\n}\nfunction parseToolCall(params, toolCall) {\n  const inputTool = params.tools?.find(inputTool => isChatCompletionFunctionTool(inputTool) && inputTool.function?.name === toolCall.function.name); // TS doesn't narrow based on isChatCompletionTool\n  return {\n    ...toolCall,\n    function: {\n      ...toolCall.function,\n      parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments) : null\n    }\n  };\n}\nexport function shouldParseToolCall(params, toolCall) {\n  if (!params || !('tools' in params) || !params.tools) {\n    return false;\n  }\n  const inputTool = params.tools?.find(inputTool => isChatCompletionFunctionTool(inputTool) && inputTool.function?.name === toolCall.function.name);\n  return isChatCompletionFunctionTool(inputTool) && (isAutoParsableTool(inputTool) || inputTool?.function.strict || false);\n}\nexport function hasAutoParseableInput(params) {\n  if (isAutoParsableResponseFormat(params.response_format)) {\n    return true;\n  }\n  return params.tools?.some(t => isAutoParsableTool(t) || t.type === 'function' && t.function.strict === true) ?? false;\n}\nexport function assertToolCallsAreChatCompletionFunctionToolCalls(toolCalls) {\n  for (const toolCall of toolCalls || []) {\n    if (toolCall.type !== 'function') {\n      throw new OpenAIError(`Currently only \\`function\\` tool calls are supported; Received \\`${toolCall.type}\\``);\n    }\n  }\n}\nexport function validateInputTools(tools) {\n  for (const tool of tools ?? []) {\n    if (tool.type !== 'function') {\n      throw new OpenAIError(`Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``);\n    }\n    if (tool.function.strict !== true) {\n      throw new OpenAIError(`The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`);\n    }\n  }\n}","map":{"version":3,"names":["ContentFilterFinishReasonError","LengthFinishReasonError","OpenAIError","isChatCompletionFunctionTool","tool","undefined","function","makeParseableResponseFormat","response_format","parser","obj","Object","defineProperties","$brand","value","enumerable","$parseRaw","makeParseableTextFormat","isAutoParsableResponseFormat","makeParseableTool","callback","$callback","isAutoParsableTool","maybeParseChatCompletion","completion","params","hasAutoParseableInput","choices","map","choice","assertToolCallsAreChatCompletionFunctionToolCalls","message","tool_calls","parsed","parseChatCompletion","finish_reason","toolCall","parseToolCall","content","refusal","parseResponseFormat","type","JSON","parse","inputTool","tools","find","name","parsed_arguments","arguments","strict","shouldParseToolCall","some","t","toolCalls","validateInputTools"],"sources":["/Users/nihalmaddala/photo-proj/node_modules/openai/src/lib/parser.ts"],"sourcesContent":["import { ContentFilterFinishReasonError, LengthFinishReasonError, OpenAIError } from '../error';\nimport {\n  ChatCompletion,\n  ChatCompletionCreateParams,\n  ChatCompletionCreateParamsBase,\n  ChatCompletionFunctionTool,\n  ChatCompletionMessage,\n  ChatCompletionMessageFunctionToolCall,\n  ChatCompletionStreamingToolRunnerParams,\n  ChatCompletionStreamParams,\n  ChatCompletionToolRunnerParams,\n  ParsedChatCompletion,\n  ParsedChoice,\n  ParsedFunctionToolCall,\n} from '../resources/chat/completions';\nimport { type ResponseFormatTextJSONSchemaConfig } from '../resources/responses/responses';\nimport { ResponseFormatJSONSchema } from '../resources/shared';\n\ntype AnyChatCompletionCreateParams =\n  | ChatCompletionCreateParams\n  | ChatCompletionToolRunnerParams<any>\n  | ChatCompletionStreamingToolRunnerParams<any>\n  | ChatCompletionStreamParams;\n\ntype Unpacked<T> = T extends (infer U)[] ? U : T;\n\ntype ToolCall = Unpacked<ChatCompletionCreateParamsBase['tools']>;\n\nexport function isChatCompletionFunctionTool(tool: ToolCall): tool is ChatCompletionFunctionTool {\n  return tool !== undefined && 'function' in tool && tool.function !== undefined;\n}\n\nexport type ExtractParsedContentFromParams<Params extends AnyChatCompletionCreateParams> =\n  Params['response_format'] extends AutoParseableResponseFormat<infer P> ? P : null;\n\nexport type AutoParseableResponseFormat<ParsedT> = ResponseFormatJSONSchema & {\n  __output: ParsedT; // type-level only\n\n  $brand: 'auto-parseable-response-format';\n  $parseRaw(content: string): ParsedT;\n};\n\nexport function makeParseableResponseFormat<ParsedT>(\n  response_format: ResponseFormatJSONSchema,\n  parser: (content: string) => ParsedT,\n): AutoParseableResponseFormat<ParsedT> {\n  const obj = { ...response_format };\n\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-response-format',\n      enumerable: false,\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false,\n    },\n  });\n\n  return obj as AutoParseableResponseFormat<ParsedT>;\n}\n\nexport type AutoParseableTextFormat<ParsedT> = ResponseFormatTextJSONSchemaConfig & {\n  __output: ParsedT; // type-level only\n\n  $brand: 'auto-parseable-response-format';\n  $parseRaw(content: string): ParsedT;\n};\n\nexport function makeParseableTextFormat<ParsedT>(\n  response_format: ResponseFormatTextJSONSchemaConfig,\n  parser: (content: string) => ParsedT,\n): AutoParseableTextFormat<ParsedT> {\n  const obj = { ...response_format };\n\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-response-format',\n      enumerable: false,\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false,\n    },\n  });\n\n  return obj as AutoParseableTextFormat<ParsedT>;\n}\n\nexport function isAutoParsableResponseFormat<ParsedT>(\n  response_format: any,\n): response_format is AutoParseableResponseFormat<ParsedT> {\n  return response_format?.['$brand'] === 'auto-parseable-response-format';\n}\n\ntype ToolOptions = {\n  name: string;\n  arguments: any;\n  function?: ((args: any) => any) | undefined;\n};\n\nexport type AutoParseableTool<\n  OptionsT extends ToolOptions,\n  HasFunction = OptionsT['function'] extends Function ? true : false,\n> = ChatCompletionFunctionTool & {\n  __arguments: OptionsT['arguments']; // type-level only\n  __name: OptionsT['name']; // type-level only\n  __hasFunction: HasFunction; // type-level only\n\n  $brand: 'auto-parseable-tool';\n  $callback: ((args: OptionsT['arguments']) => any) | undefined;\n  $parseRaw(args: string): OptionsT['arguments'];\n};\n\nexport function makeParseableTool<OptionsT extends ToolOptions>(\n  tool: ChatCompletionFunctionTool,\n  {\n    parser,\n    callback,\n  }: {\n    parser: (content: string) => OptionsT['arguments'];\n    callback: ((args: any) => any) | undefined;\n  },\n): AutoParseableTool<OptionsT['arguments']> {\n  const obj = { ...tool };\n\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-tool',\n      enumerable: false,\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false,\n    },\n    $callback: {\n      value: callback,\n      enumerable: false,\n    },\n  });\n\n  return obj as AutoParseableTool<OptionsT['arguments']>;\n}\n\nexport function isAutoParsableTool(tool: any): tool is AutoParseableTool<any> {\n  return tool?.['$brand'] === 'auto-parseable-tool';\n}\n\nexport function maybeParseChatCompletion<\n  Params extends ChatCompletionCreateParams | null,\n  ParsedT = Params extends null ? null : ExtractParsedContentFromParams<NonNullable<Params>>,\n>(completion: ChatCompletion, params: Params): ParsedChatCompletion<ParsedT> {\n  if (!params || !hasAutoParseableInput(params)) {\n    return {\n      ...completion,\n      choices: completion.choices.map((choice) => {\n        assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);\n\n        return {\n          ...choice,\n          message: {\n            ...choice.message,\n            parsed: null,\n            ...(choice.message.tool_calls ?\n              {\n                tool_calls: choice.message.tool_calls,\n              }\n            : undefined),\n          },\n        };\n      }),\n    } as ParsedChatCompletion<ParsedT>;\n  }\n\n  return parseChatCompletion(completion, params);\n}\n\nexport function parseChatCompletion<\n  Params extends ChatCompletionCreateParams,\n  ParsedT = ExtractParsedContentFromParams<Params>,\n>(completion: ChatCompletion, params: Params): ParsedChatCompletion<ParsedT> {\n  const choices: Array<ParsedChoice<ParsedT>> = completion.choices.map((choice): ParsedChoice<ParsedT> => {\n    if (choice.finish_reason === 'length') {\n      throw new LengthFinishReasonError();\n    }\n\n    if (choice.finish_reason === 'content_filter') {\n      throw new ContentFilterFinishReasonError();\n    }\n\n    assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);\n\n    return {\n      ...choice,\n      message: {\n        ...choice.message,\n        ...(choice.message.tool_calls ?\n          {\n            tool_calls:\n              choice.message.tool_calls?.map((toolCall) => parseToolCall(params, toolCall)) ?? undefined,\n          }\n        : undefined),\n        parsed:\n          choice.message.content && !choice.message.refusal ?\n            parseResponseFormat(params, choice.message.content)\n          : null,\n      },\n    } as ParsedChoice<ParsedT>;\n  });\n\n  return { ...completion, choices };\n}\n\nfunction parseResponseFormat<\n  Params extends ChatCompletionCreateParams,\n  ParsedT = ExtractParsedContentFromParams<Params>,\n>(params: Params, content: string): ParsedT | null {\n  if (params.response_format?.type !== 'json_schema') {\n    return null;\n  }\n\n  if (params.response_format?.type === 'json_schema') {\n    if ('$parseRaw' in params.response_format) {\n      const response_format = params.response_format as AutoParseableResponseFormat<ParsedT>;\n\n      return response_format.$parseRaw(content);\n    }\n\n    return JSON.parse(content);\n  }\n\n  return null;\n}\n\nfunction parseToolCall<Params extends ChatCompletionCreateParams>(\n  params: Params,\n  toolCall: ChatCompletionMessageFunctionToolCall,\n): ParsedFunctionToolCall {\n  const inputTool = params.tools?.find(\n    (inputTool) =>\n      isChatCompletionFunctionTool(inputTool) && inputTool.function?.name === toolCall.function.name,\n  ) as ChatCompletionFunctionTool | undefined; // TS doesn't narrow based on isChatCompletionTool\n  return {\n    ...toolCall,\n    function: {\n      ...toolCall.function,\n      parsed_arguments:\n        isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments)\n        : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments)\n        : null,\n    },\n  };\n}\n\nexport function shouldParseToolCall(\n  params: ChatCompletionCreateParams | null | undefined,\n  toolCall: ChatCompletionMessageFunctionToolCall,\n): boolean {\n  if (!params || !('tools' in params) || !params.tools) {\n    return false;\n  }\n\n  const inputTool = params.tools?.find(\n    (inputTool) =>\n      isChatCompletionFunctionTool(inputTool) && inputTool.function?.name === toolCall.function.name,\n  );\n  return (\n    isChatCompletionFunctionTool(inputTool) &&\n    (isAutoParsableTool(inputTool) || inputTool?.function.strict || false)\n  );\n}\n\nexport function hasAutoParseableInput(params: AnyChatCompletionCreateParams): boolean {\n  if (isAutoParsableResponseFormat(params.response_format)) {\n    return true;\n  }\n\n  return (\n    params.tools?.some(\n      (t) => isAutoParsableTool(t) || (t.type === 'function' && t.function.strict === true),\n    ) ?? false\n  );\n}\n\nexport function assertToolCallsAreChatCompletionFunctionToolCalls(\n  toolCalls: ChatCompletionMessage['tool_calls'],\n): asserts toolCalls is ChatCompletionMessageFunctionToolCall[] {\n  for (const toolCall of toolCalls || []) {\n    if (toolCall.type !== 'function') {\n      throw new OpenAIError(\n        `Currently only \\`function\\` tool calls are supported; Received \\`${toolCall.type}\\``,\n      );\n    }\n  }\n}\n\nexport function validateInputTools(tools: ChatCompletionCreateParamsBase['tools']) {\n  for (const tool of tools ?? []) {\n    if (tool.type !== 'function') {\n      throw new OpenAIError(\n        `Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``,\n      );\n    }\n\n    if (tool.function.strict !== true) {\n      throw new OpenAIError(\n        `The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`,\n      );\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}