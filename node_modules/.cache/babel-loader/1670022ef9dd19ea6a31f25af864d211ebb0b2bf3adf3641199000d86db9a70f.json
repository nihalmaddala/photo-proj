{"ast":null,"code":"import { OpenAIError } from \"../../core/error.mjs\";\n/**\n * Percent-encode everything that isn't safe to have in a path without encoding safe chars.\n *\n * Taken from https://datatracker.ietf.org/doc/html/rfc3986#section-3.3:\n * > unreserved  = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n * > sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n * > pchar       = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n */\nexport function encodeURIPath(str) {\n  return str.replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);\n}\nconst EMPTY = /* @__PURE__ */Object.freeze(/* @__PURE__ */Object.create(null));\nexport const createPathTagFunction = (pathEncoder = encodeURIPath) => function path(statics, ...params) {\n  // If there are no params, no processing is needed.\n  if (statics.length === 1) return statics[0];\n  let postPath = false;\n  const invalidSegments = [];\n  const path = statics.reduce((previousValue, currentValue, index) => {\n    if (/[?#]/.test(currentValue)) {\n      postPath = true;\n    }\n    const value = params[index];\n    let encoded = (postPath ? encodeURIComponent : pathEncoder)('' + value);\n    if (index !== params.length && (value == null || typeof value === 'object' &&\n    // handle values from other realms\n    value.toString === Object.getPrototypeOf(Object.getPrototypeOf(value.hasOwnProperty ?? EMPTY) ?? EMPTY)?.toString)) {\n      encoded = value + '';\n      invalidSegments.push({\n        start: previousValue.length + currentValue.length,\n        length: encoded.length,\n        error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`\n      });\n    }\n    return previousValue + currentValue + (index === params.length ? '' : encoded);\n  }, '');\n  const pathOnly = path.split(/[?#]/, 1)[0];\n  const invalidSegmentPattern = /(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)/gi;\n  let match;\n  // Find all invalid segments\n  while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {\n    invalidSegments.push({\n      start: match.index,\n      length: match[0].length,\n      error: `Value \"${match[0]}\" can\\'t be safely passed as a path parameter`\n    });\n  }\n  invalidSegments.sort((a, b) => a.start - b.start);\n  if (invalidSegments.length > 0) {\n    let lastEnd = 0;\n    const underline = invalidSegments.reduce((acc, segment) => {\n      const spaces = ' '.repeat(segment.start - lastEnd);\n      const arrows = '^'.repeat(segment.length);\n      lastEnd = segment.start + segment.length;\n      return acc + spaces + arrows;\n    }, '');\n    throw new OpenAIError(`Path parameters result in path with invalid segments:\\n${invalidSegments.map(e => e.error).join('\\n')}\\n${path}\\n${underline}`);\n  }\n  return path;\n};\n/**\n * URI-encodes path params and ensures no unsafe /./ or /../ path segments are introduced.\n */\nexport const path = /* @__PURE__ */createPathTagFunction(encodeURIPath);","map":{"version":3,"names":["OpenAIError","encodeURIPath","str","replace","encodeURIComponent","EMPTY","Object","freeze","create","createPathTagFunction","pathEncoder","path","statics","params","length","postPath","invalidSegments","reduce","previousValue","currentValue","index","test","value","encoded","toString","getPrototypeOf","hasOwnProperty","push","start","error","prototype","call","slice","pathOnly","split","invalidSegmentPattern","match","exec","sort","a","b","lastEnd","underline","acc","segment","spaces","repeat","arrows","map","e","join"],"sources":["/Users/nihalmaddala/photo-proj/node_modules/openai/src/internal/utils/path.ts"],"sourcesContent":["import { OpenAIError } from '../../core/error';\n\n/**\n * Percent-encode everything that isn't safe to have in a path without encoding safe chars.\n *\n * Taken from https://datatracker.ietf.org/doc/html/rfc3986#section-3.3:\n * > unreserved  = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n * > sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n * > pchar       = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n */\nexport function encodeURIPath(str: string) {\n  return str.replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);\n}\n\nconst EMPTY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));\n\nexport const createPathTagFunction = (pathEncoder = encodeURIPath) =>\n  function path(statics: readonly string[], ...params: readonly unknown[]): string {\n    // If there are no params, no processing is needed.\n    if (statics.length === 1) return statics[0]!;\n\n    let postPath = false;\n    const invalidSegments = [];\n    const path = statics.reduce((previousValue, currentValue, index) => {\n      if (/[?#]/.test(currentValue)) {\n        postPath = true;\n      }\n      const value = params[index];\n      let encoded = (postPath ? encodeURIComponent : pathEncoder)('' + value);\n      if (\n        index !== params.length &&\n        (value == null ||\n          (typeof value === 'object' &&\n            // handle values from other realms\n            value.toString ===\n              Object.getPrototypeOf(Object.getPrototypeOf((value as any).hasOwnProperty ?? EMPTY) ?? EMPTY)\n                ?.toString))\n      ) {\n        encoded = value + '';\n        invalidSegments.push({\n          start: previousValue.length + currentValue.length,\n          length: encoded.length,\n          error: `Value of type ${Object.prototype.toString\n            .call(value)\n            .slice(8, -1)} is not a valid path parameter`,\n        });\n      }\n      return previousValue + currentValue + (index === params.length ? '' : encoded);\n    }, '');\n\n    const pathOnly = path.split(/[?#]/, 1)[0]!;\n    const invalidSegmentPattern = /(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)/gi;\n    let match;\n\n    // Find all invalid segments\n    while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {\n      invalidSegments.push({\n        start: match.index,\n        length: match[0].length,\n        error: `Value \"${match[0]}\" can\\'t be safely passed as a path parameter`,\n      });\n    }\n\n    invalidSegments.sort((a, b) => a.start - b.start);\n\n    if (invalidSegments.length > 0) {\n      let lastEnd = 0;\n      const underline = invalidSegments.reduce((acc, segment) => {\n        const spaces = ' '.repeat(segment.start - lastEnd);\n        const arrows = '^'.repeat(segment.length);\n        lastEnd = segment.start + segment.length;\n        return acc + spaces + arrows;\n      }, '');\n\n      throw new OpenAIError(\n        `Path parameters result in path with invalid segments:\\n${invalidSegments\n          .map((e) => e.error)\n          .join('\\n')}\\n${path}\\n${underline}`,\n      );\n    }\n\n    return path;\n  };\n\n/**\n * URI-encodes path params and ensures no unsafe /./ or /../ path segments are introduced.\n */\nexport const path = /* @__PURE__ */ createPathTagFunction(encodeURIPath);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}