{"ast":null,"code":"// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar _AbstractPage_client;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"../internal/tslib.mjs\";\nimport { OpenAIError } from \"./error.mjs\";\nimport { defaultParseResponse } from \"../internal/parse.mjs\";\nimport { APIPromise } from \"./api-promise.mjs\";\nimport { maybeObj } from \"../internal/utils/values.mjs\";\nexport class AbstractPage {\n  constructor(client, response, body, options) {\n    _AbstractPage_client.set(this, void 0);\n    __classPrivateFieldSet(this, _AbstractPage_client, client, \"f\");\n    this.options = options;\n    this.response = response;\n    this.body = body;\n  }\n  hasNextPage() {\n    const items = this.getPaginatedItems();\n    if (!items.length) return false;\n    return this.nextPageRequestOptions() != null;\n  }\n  async getNextPage() {\n    const nextOptions = this.nextPageRequestOptions();\n    if (!nextOptions) {\n      throw new OpenAIError('No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.');\n    }\n    return await __classPrivateFieldGet(this, _AbstractPage_client, \"f\").requestAPIList(this.constructor, nextOptions);\n  }\n  async *iterPages() {\n    let page = this;\n    yield page;\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n  async *[(_AbstractPage_client = new WeakMap(), Symbol.asyncIterator)]() {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n}\n/**\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\n *\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n *\n *    for await (const item of client.items.list()) {\n *      console.log(item)\n *    }\n */\nexport class PagePromise extends APIPromise {\n  constructor(client, request, Page) {\n    super(client, request, async (client, props) => new Page(client, props.response, await defaultParseResponse(client, props), props.options));\n  }\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator]() {\n    const page = await this;\n    for await (const item of page) {\n      yield item;\n    }\n  }\n}\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class Page extends AbstractPage {\n  constructor(client, response, body, options) {\n    super(client, response, body, options);\n    this.data = body.data || [];\n    this.object = body.object;\n  }\n  getPaginatedItems() {\n    return this.data ?? [];\n  }\n  nextPageRequestOptions() {\n    return null;\n  }\n}\nexport class CursorPage extends AbstractPage {\n  constructor(client, response, body, options) {\n    super(client, response, body, options);\n    this.data = body.data || [];\n    this.has_more = body.has_more || false;\n  }\n  getPaginatedItems() {\n    return this.data ?? [];\n  }\n  hasNextPage() {\n    if (this.has_more === false) {\n      return false;\n    }\n    return super.hasNextPage();\n  }\n  nextPageRequestOptions() {\n    const data = this.getPaginatedItems();\n    const id = data[data.length - 1]?.id;\n    if (!id) {\n      return null;\n    }\n    return {\n      ...this.options,\n      query: {\n        ...maybeObj(this.options.query),\n        after: id\n      }\n    };\n  }\n}\nexport class ConversationCursorPage extends AbstractPage {\n  constructor(client, response, body, options) {\n    super(client, response, body, options);\n    this.data = body.data || [];\n    this.has_more = body.has_more || false;\n    this.last_id = body.last_id || '';\n  }\n  getPaginatedItems() {\n    return this.data ?? [];\n  }\n  hasNextPage() {\n    if (this.has_more === false) {\n      return false;\n    }\n    return super.hasNextPage();\n  }\n  nextPageRequestOptions() {\n    const cursor = this.last_id;\n    if (!cursor) {\n      return null;\n    }\n    return {\n      ...this.options,\n      query: {\n        ...maybeObj(this.options.query),\n        after: cursor\n      }\n    };\n  }\n}","map":{"version":3,"names":["OpenAIError","defaultParseResponse","APIPromise","maybeObj","AbstractPage","constructor","client","response","body","options","_AbstractPage_client","set","__classPrivateFieldSet","hasNextPage","items","getPaginatedItems","length","nextPageRequestOptions","getNextPage","nextOptions","__classPrivateFieldGet","requestAPIList","iterPages","page","WeakMap","Symbol","asyncIterator","item","PagePromise","request","Page","props","data","object","CursorPage","has_more","id","query","after","ConversationCursorPage","last_id","cursor"],"sources":["/Users/nihalmaddala/photo-proj/node_modules/openai/src/core/pagination.ts"],"sourcesContent":["// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { OpenAIError } from './error';\nimport { FinalRequestOptions } from '../internal/request-options';\nimport { defaultParseResponse, WithRequestID } from '../internal/parse';\nimport { APIPromise } from './api-promise';\nimport { type OpenAI } from '../client';\nimport { type APIResponseProps } from '../internal/parse';\nimport { maybeObj } from '../internal/utils/values';\n\nexport type PageRequestOptions = Pick<FinalRequestOptions, 'query' | 'headers' | 'body' | 'path' | 'method'>;\n\nexport abstract class AbstractPage<Item> implements AsyncIterable<Item> {\n  #client: OpenAI;\n  protected options: FinalRequestOptions;\n\n  protected response: Response;\n  protected body: unknown;\n\n  constructor(client: OpenAI, response: Response, body: unknown, options: FinalRequestOptions) {\n    this.#client = client;\n    this.options = options;\n    this.response = response;\n    this.body = body;\n  }\n\n  abstract nextPageRequestOptions(): PageRequestOptions | null;\n\n  abstract getPaginatedItems(): Item[];\n\n  hasNextPage(): boolean {\n    const items = this.getPaginatedItems();\n    if (!items.length) return false;\n    return this.nextPageRequestOptions() != null;\n  }\n\n  async getNextPage(): Promise<this> {\n    const nextOptions = this.nextPageRequestOptions();\n    if (!nextOptions) {\n      throw new OpenAIError(\n        'No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.',\n      );\n    }\n\n    return await this.#client.requestAPIList(this.constructor as any, nextOptions);\n  }\n\n  async *iterPages(): AsyncGenerator<this> {\n    let page: this = this;\n    yield page;\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<Item> {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n}\n\n/**\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\n *\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n *\n *    for await (const item of client.items.list()) {\n *      console.log(item)\n *    }\n */\nexport class PagePromise<\n    PageClass extends AbstractPage<Item>,\n    Item = ReturnType<PageClass['getPaginatedItems']>[number],\n  >\n  extends APIPromise<PageClass>\n  implements AsyncIterable<Item>\n{\n  constructor(\n    client: OpenAI,\n    request: Promise<APIResponseProps>,\n    Page: new (...args: ConstructorParameters<typeof AbstractPage>) => PageClass,\n  ) {\n    super(\n      client,\n      request,\n      async (client, props) =>\n        new Page(\n          client,\n          props.response,\n          await defaultParseResponse(client, props),\n          props.options,\n        ) as WithRequestID<PageClass>,\n    );\n  }\n\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator](): AsyncGenerator<Item> {\n    const page = await this;\n    for await (const item of page) {\n      yield item;\n    }\n  }\n}\n\nexport interface PageResponse<Item> {\n  data: Array<Item>;\n\n  object: string;\n}\n\n/**\n * Note: no pagination actually occurs yet, this is for forwards-compatibility.\n */\nexport class Page<Item> extends AbstractPage<Item> implements PageResponse<Item> {\n  data: Array<Item>;\n\n  object: string;\n\n  constructor(client: OpenAI, response: Response, body: PageResponse<Item>, options: FinalRequestOptions) {\n    super(client, response, body, options);\n\n    this.data = body.data || [];\n    this.object = body.object;\n  }\n\n  getPaginatedItems(): Item[] {\n    return this.data ?? [];\n  }\n\n  nextPageRequestOptions(): PageRequestOptions | null {\n    return null;\n  }\n}\n\nexport interface CursorPageResponse<Item> {\n  data: Array<Item>;\n\n  has_more: boolean;\n}\n\nexport interface CursorPageParams {\n  after?: string;\n\n  limit?: number;\n}\n\nexport class CursorPage<Item extends { id: string }>\n  extends AbstractPage<Item>\n  implements CursorPageResponse<Item>\n{\n  data: Array<Item>;\n\n  has_more: boolean;\n\n  constructor(\n    client: OpenAI,\n    response: Response,\n    body: CursorPageResponse<Item>,\n    options: FinalRequestOptions,\n  ) {\n    super(client, response, body, options);\n\n    this.data = body.data || [];\n    this.has_more = body.has_more || false;\n  }\n\n  getPaginatedItems(): Item[] {\n    return this.data ?? [];\n  }\n\n  override hasNextPage(): boolean {\n    if (this.has_more === false) {\n      return false;\n    }\n\n    return super.hasNextPage();\n  }\n\n  nextPageRequestOptions(): PageRequestOptions | null {\n    const data = this.getPaginatedItems();\n    const id = data[data.length - 1]?.id;\n    if (!id) {\n      return null;\n    }\n\n    return {\n      ...this.options,\n      query: {\n        ...maybeObj(this.options.query),\n        after: id,\n      },\n    };\n  }\n}\n\nexport interface ConversationCursorPageResponse<Item> {\n  data: Array<Item>;\n\n  has_more: boolean;\n\n  last_id: string;\n}\n\nexport interface ConversationCursorPageParams {\n  after?: string;\n\n  limit?: number;\n}\n\nexport class ConversationCursorPage<Item>\n  extends AbstractPage<Item>\n  implements ConversationCursorPageResponse<Item>\n{\n  data: Array<Item>;\n\n  has_more: boolean;\n\n  last_id: string;\n\n  constructor(\n    client: OpenAI,\n    response: Response,\n    body: ConversationCursorPageResponse<Item>,\n    options: FinalRequestOptions,\n  ) {\n    super(client, response, body, options);\n\n    this.data = body.data || [];\n    this.has_more = body.has_more || false;\n    this.last_id = body.last_id || '';\n  }\n\n  getPaginatedItems(): Item[] {\n    return this.data ?? [];\n  }\n\n  override hasNextPage(): boolean {\n    if (this.has_more === false) {\n      return false;\n    }\n\n    return super.hasNextPage();\n  }\n\n  nextPageRequestOptions(): PageRequestOptions | null {\n    const cursor = this.last_id;\n    if (!cursor) {\n      return null;\n    }\n\n    return {\n      ...this.options,\n      query: {\n        ...maybeObj(this.options.query),\n        after: cursor,\n      },\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}