{"ast":null,"code":"// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar _Webhooks_instances, _Webhooks_validateSecret, _Webhooks_getRequiredHeader;\nimport { __classPrivateFieldGet } from \"../internal/tslib.mjs\";\nimport { InvalidWebhookSignatureError } from \"../error.mjs\";\nimport { APIResource } from \"../core/resource.mjs\";\nimport { buildHeaders } from \"../internal/headers.mjs\";\nexport class Webhooks extends APIResource {\n  constructor() {\n    super(...arguments);\n    _Webhooks_instances.add(this);\n  }\n  /**\n   * Validates that the given payload was sent by OpenAI and parses the payload.\n   */\n  async unwrap(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {\n    await this.verifySignature(payload, headers, secret, tolerance);\n    return JSON.parse(payload);\n  }\n  /**\n   * Validates whether or not the webhook payload was sent by OpenAI.\n   *\n   * An error will be raised if the webhook payload was not sent by OpenAI.\n   *\n   * @param payload - The webhook payload\n   * @param headers - The webhook headers\n   * @param secret - The webhook secret (optional, will use client secret if not provided)\n   * @param tolerance - Maximum age of the webhook in seconds (default: 300 = 5 minutes)\n   */\n  async verifySignature(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {\n    if (typeof crypto === 'undefined' || typeof crypto.subtle.importKey !== 'function' || typeof crypto.subtle.verify !== 'function') {\n      throw new Error('Webhook signature verification is only supported when the `crypto` global is defined');\n    }\n    __classPrivateFieldGet(this, _Webhooks_instances, \"m\", _Webhooks_validateSecret).call(this, secret);\n    const headersObj = buildHeaders([headers]).values;\n    const signatureHeader = __classPrivateFieldGet(this, _Webhooks_instances, \"m\", _Webhooks_getRequiredHeader).call(this, headersObj, 'webhook-signature');\n    const timestamp = __classPrivateFieldGet(this, _Webhooks_instances, \"m\", _Webhooks_getRequiredHeader).call(this, headersObj, 'webhook-timestamp');\n    const webhookId = __classPrivateFieldGet(this, _Webhooks_instances, \"m\", _Webhooks_getRequiredHeader).call(this, headersObj, 'webhook-id');\n    // Validate timestamp to prevent replay attacks\n    const timestampSeconds = parseInt(timestamp, 10);\n    if (isNaN(timestampSeconds)) {\n      throw new InvalidWebhookSignatureError('Invalid webhook timestamp format');\n    }\n    const nowSeconds = Math.floor(Date.now() / 1000);\n    if (nowSeconds - timestampSeconds > tolerance) {\n      throw new InvalidWebhookSignatureError('Webhook timestamp is too old');\n    }\n    if (timestampSeconds > nowSeconds + tolerance) {\n      throw new InvalidWebhookSignatureError('Webhook timestamp is too new');\n    }\n    // Extract signatures from v1,<base64> format\n    // The signature header can have multiple values, separated by spaces.\n    // Each value is in the format v1,<base64>. We should accept if any match.\n    const signatures = signatureHeader.split(' ').map(part => part.startsWith('v1,') ? part.substring(3) : part);\n    // Decode the secret if it starts with whsec_\n    const decodedSecret = secret.startsWith('whsec_') ? Buffer.from(secret.replace('whsec_', ''), 'base64') : Buffer.from(secret, 'utf-8');\n    // Create the signed payload: {webhook_id}.{timestamp}.{payload}\n    const signedPayload = webhookId ? `${webhookId}.${timestamp}.${payload}` : `${timestamp}.${payload}`;\n    // Import the secret as a cryptographic key for HMAC\n    const key = await crypto.subtle.importKey('raw', decodedSecret, {\n      name: 'HMAC',\n      hash: 'SHA-256'\n    }, false, ['verify']);\n    // Check if any signature matches using timing-safe WebCrypto verify\n    for (const signature of signatures) {\n      try {\n        const signatureBytes = Buffer.from(signature, 'base64');\n        const isValid = await crypto.subtle.verify('HMAC', key, signatureBytes, new TextEncoder().encode(signedPayload));\n        if (isValid) {\n          return; // Valid signature found\n        }\n      } catch {\n        // Invalid base64 or signature format, continue to next signature\n        continue;\n      }\n    }\n    throw new InvalidWebhookSignatureError('The given webhook signature does not match the expected signature');\n  }\n}\n_Webhooks_instances = new WeakSet(), _Webhooks_validateSecret = function _Webhooks_validateSecret(secret) {\n  if (typeof secret !== 'string' || secret.length === 0) {\n    throw new Error(`The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function`);\n  }\n}, _Webhooks_getRequiredHeader = function _Webhooks_getRequiredHeader(headers, name) {\n  if (!headers) {\n    throw new Error(`Headers are required`);\n  }\n  const value = headers.get(name);\n  if (value === null || value === undefined) {\n    throw new Error(`Missing required header: ${name}`);\n  }\n  return value;\n};","map":{"version":3,"names":["InvalidWebhookSignatureError","APIResource","buildHeaders","Webhooks","constructor","unwrap","payload","headers","secret","_client","webhookSecret","tolerance","verifySignature","JSON","parse","crypto","subtle","importKey","verify","Error","__classPrivateFieldGet","_Webhooks_instances","_Webhooks_validateSecret","call","headersObj","values","signatureHeader","_Webhooks_getRequiredHeader","timestamp","webhookId","timestampSeconds","parseInt","isNaN","nowSeconds","Math","floor","Date","now","signatures","split","map","part","startsWith","substring","decodedSecret","Buffer","from","replace","signedPayload","key","name","hash","signature","signatureBytes","isValid","TextEncoder","encode","length","value","get","undefined"],"sources":["/Users/nihalmaddala/photo-proj/node_modules/openai/src/resources/webhooks.ts"],"sourcesContent":["// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { InvalidWebhookSignatureError } from '../error';\nimport { APIResource } from '../core/resource';\nimport { buildHeaders, HeadersLike } from '../internal/headers';\n\nexport class Webhooks extends APIResource {\n  /**\n   * Validates that the given payload was sent by OpenAI and parses the payload.\n   */\n  async unwrap(\n    payload: string,\n    headers: HeadersLike,\n    secret: string | undefined | null = this._client.webhookSecret,\n    tolerance: number = 300,\n  ): Promise<UnwrapWebhookEvent> {\n    await this.verifySignature(payload, headers, secret, tolerance);\n\n    return JSON.parse(payload) as UnwrapWebhookEvent;\n  }\n\n  /**\n   * Validates whether or not the webhook payload was sent by OpenAI.\n   *\n   * An error will be raised if the webhook payload was not sent by OpenAI.\n   *\n   * @param payload - The webhook payload\n   * @param headers - The webhook headers\n   * @param secret - The webhook secret (optional, will use client secret if not provided)\n   * @param tolerance - Maximum age of the webhook in seconds (default: 300 = 5 minutes)\n   */\n  async verifySignature(\n    payload: string,\n    headers: HeadersLike,\n    secret: string | undefined | null = this._client.webhookSecret,\n    tolerance: number = 300,\n  ): Promise<void> {\n    if (\n      typeof crypto === 'undefined' ||\n      typeof crypto.subtle.importKey !== 'function' ||\n      typeof crypto.subtle.verify !== 'function'\n    ) {\n      throw new Error('Webhook signature verification is only supported when the `crypto` global is defined');\n    }\n\n    this.#validateSecret(secret);\n\n    const headersObj = buildHeaders([headers]).values;\n    const signatureHeader = this.#getRequiredHeader(headersObj, 'webhook-signature');\n    const timestamp = this.#getRequiredHeader(headersObj, 'webhook-timestamp');\n    const webhookId = this.#getRequiredHeader(headersObj, 'webhook-id');\n\n    // Validate timestamp to prevent replay attacks\n    const timestampSeconds = parseInt(timestamp, 10);\n    if (isNaN(timestampSeconds)) {\n      throw new InvalidWebhookSignatureError('Invalid webhook timestamp format');\n    }\n\n    const nowSeconds = Math.floor(Date.now() / 1000);\n\n    if (nowSeconds - timestampSeconds > tolerance) {\n      throw new InvalidWebhookSignatureError('Webhook timestamp is too old');\n    }\n\n    if (timestampSeconds > nowSeconds + tolerance) {\n      throw new InvalidWebhookSignatureError('Webhook timestamp is too new');\n    }\n\n    // Extract signatures from v1,<base64> format\n    // The signature header can have multiple values, separated by spaces.\n    // Each value is in the format v1,<base64>. We should accept if any match.\n    const signatures = signatureHeader\n      .split(' ')\n      .map((part) => (part.startsWith('v1,') ? part.substring(3) : part));\n\n    // Decode the secret if it starts with whsec_\n    const decodedSecret =\n      secret.startsWith('whsec_') ?\n        Buffer.from(secret.replace('whsec_', ''), 'base64')\n      : Buffer.from(secret, 'utf-8');\n\n    // Create the signed payload: {webhook_id}.{timestamp}.{payload}\n    const signedPayload = webhookId ? `${webhookId}.${timestamp}.${payload}` : `${timestamp}.${payload}`;\n\n    // Import the secret as a cryptographic key for HMAC\n    const key = await crypto.subtle.importKey(\n      'raw',\n      decodedSecret,\n      { name: 'HMAC', hash: 'SHA-256' },\n      false,\n      ['verify'],\n    );\n\n    // Check if any signature matches using timing-safe WebCrypto verify\n    for (const signature of signatures) {\n      try {\n        const signatureBytes = Buffer.from(signature, 'base64');\n        const isValid = await crypto.subtle.verify(\n          'HMAC',\n          key,\n          signatureBytes,\n          new TextEncoder().encode(signedPayload),\n        );\n\n        if (isValid) {\n          return; // Valid signature found\n        }\n      } catch {\n        // Invalid base64 or signature format, continue to next signature\n        continue;\n      }\n    }\n\n    throw new InvalidWebhookSignatureError(\n      'The given webhook signature does not match the expected signature',\n    );\n  }\n\n  #validateSecret(secret: string | null | undefined): asserts secret is string {\n    if (typeof secret !== 'string' || secret.length === 0) {\n      throw new Error(\n        `The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function`,\n      );\n    }\n  }\n\n  #getRequiredHeader(headers: Headers, name: string): string {\n    if (!headers) {\n      throw new Error(`Headers are required`);\n    }\n\n    const value = headers.get(name);\n\n    if (value === null || value === undefined) {\n      throw new Error(`Missing required header: ${name}`);\n    }\n\n    return value;\n  }\n}\n\n/**\n * Sent when a batch API request has been cancelled.\n */\nexport interface BatchCancelledWebhookEvent {\n  /**\n   * The unique ID of the event.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) of when the batch API request was cancelled.\n   */\n  created_at: number;\n\n  /**\n   * Event data payload.\n   */\n  data: BatchCancelledWebhookEvent.Data;\n\n  /**\n   * The type of the event. Always `batch.cancelled`.\n   */\n  type: 'batch.cancelled';\n\n  /**\n   * The object of the event. Always `event`.\n   */\n  object?: 'event';\n}\n\nexport namespace BatchCancelledWebhookEvent {\n  /**\n   * Event data payload.\n   */\n  export interface Data {\n    /**\n     * The unique ID of the batch API request.\n     */\n    id: string;\n  }\n}\n\n/**\n * Sent when a batch API request has been completed.\n */\nexport interface BatchCompletedWebhookEvent {\n  /**\n   * The unique ID of the event.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) of when the batch API request was completed.\n   */\n  created_at: number;\n\n  /**\n   * Event data payload.\n   */\n  data: BatchCompletedWebhookEvent.Data;\n\n  /**\n   * The type of the event. Always `batch.completed`.\n   */\n  type: 'batch.completed';\n\n  /**\n   * The object of the event. Always `event`.\n   */\n  object?: 'event';\n}\n\nexport namespace BatchCompletedWebhookEvent {\n  /**\n   * Event data payload.\n   */\n  export interface Data {\n    /**\n     * The unique ID of the batch API request.\n     */\n    id: string;\n  }\n}\n\n/**\n * Sent when a batch API request has expired.\n */\nexport interface BatchExpiredWebhookEvent {\n  /**\n   * The unique ID of the event.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) of when the batch API request expired.\n   */\n  created_at: number;\n\n  /**\n   * Event data payload.\n   */\n  data: BatchExpiredWebhookEvent.Data;\n\n  /**\n   * The type of the event. Always `batch.expired`.\n   */\n  type: 'batch.expired';\n\n  /**\n   * The object of the event. Always `event`.\n   */\n  object?: 'event';\n}\n\nexport namespace BatchExpiredWebhookEvent {\n  /**\n   * Event data payload.\n   */\n  export interface Data {\n    /**\n     * The unique ID of the batch API request.\n     */\n    id: string;\n  }\n}\n\n/**\n * Sent when a batch API request has failed.\n */\nexport interface BatchFailedWebhookEvent {\n  /**\n   * The unique ID of the event.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) of when the batch API request failed.\n   */\n  created_at: number;\n\n  /**\n   * Event data payload.\n   */\n  data: BatchFailedWebhookEvent.Data;\n\n  /**\n   * The type of the event. Always `batch.failed`.\n   */\n  type: 'batch.failed';\n\n  /**\n   * The object of the event. Always `event`.\n   */\n  object?: 'event';\n}\n\nexport namespace BatchFailedWebhookEvent {\n  /**\n   * Event data payload.\n   */\n  export interface Data {\n    /**\n     * The unique ID of the batch API request.\n     */\n    id: string;\n  }\n}\n\n/**\n * Sent when an eval run has been canceled.\n */\nexport interface EvalRunCanceledWebhookEvent {\n  /**\n   * The unique ID of the event.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) of when the eval run was canceled.\n   */\n  created_at: number;\n\n  /**\n   * Event data payload.\n   */\n  data: EvalRunCanceledWebhookEvent.Data;\n\n  /**\n   * The type of the event. Always `eval.run.canceled`.\n   */\n  type: 'eval.run.canceled';\n\n  /**\n   * The object of the event. Always `event`.\n   */\n  object?: 'event';\n}\n\nexport namespace EvalRunCanceledWebhookEvent {\n  /**\n   * Event data payload.\n   */\n  export interface Data {\n    /**\n     * The unique ID of the eval run.\n     */\n    id: string;\n  }\n}\n\n/**\n * Sent when an eval run has failed.\n */\nexport interface EvalRunFailedWebhookEvent {\n  /**\n   * The unique ID of the event.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) of when the eval run failed.\n   */\n  created_at: number;\n\n  /**\n   * Event data payload.\n   */\n  data: EvalRunFailedWebhookEvent.Data;\n\n  /**\n   * The type of the event. Always `eval.run.failed`.\n   */\n  type: 'eval.run.failed';\n\n  /**\n   * The object of the event. Always `event`.\n   */\n  object?: 'event';\n}\n\nexport namespace EvalRunFailedWebhookEvent {\n  /**\n   * Event data payload.\n   */\n  export interface Data {\n    /**\n     * The unique ID of the eval run.\n     */\n    id: string;\n  }\n}\n\n/**\n * Sent when an eval run has succeeded.\n */\nexport interface EvalRunSucceededWebhookEvent {\n  /**\n   * The unique ID of the event.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) of when the eval run succeeded.\n   */\n  created_at: number;\n\n  /**\n   * Event data payload.\n   */\n  data: EvalRunSucceededWebhookEvent.Data;\n\n  /**\n   * The type of the event. Always `eval.run.succeeded`.\n   */\n  type: 'eval.run.succeeded';\n\n  /**\n   * The object of the event. Always `event`.\n   */\n  object?: 'event';\n}\n\nexport namespace EvalRunSucceededWebhookEvent {\n  /**\n   * Event data payload.\n   */\n  export interface Data {\n    /**\n     * The unique ID of the eval run.\n     */\n    id: string;\n  }\n}\n\n/**\n * Sent when a fine-tuning job has been cancelled.\n */\nexport interface FineTuningJobCancelledWebhookEvent {\n  /**\n   * The unique ID of the event.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) of when the fine-tuning job was cancelled.\n   */\n  created_at: number;\n\n  /**\n   * Event data payload.\n   */\n  data: FineTuningJobCancelledWebhookEvent.Data;\n\n  /**\n   * The type of the event. Always `fine_tuning.job.cancelled`.\n   */\n  type: 'fine_tuning.job.cancelled';\n\n  /**\n   * The object of the event. Always `event`.\n   */\n  object?: 'event';\n}\n\nexport namespace FineTuningJobCancelledWebhookEvent {\n  /**\n   * Event data payload.\n   */\n  export interface Data {\n    /**\n     * The unique ID of the fine-tuning job.\n     */\n    id: string;\n  }\n}\n\n/**\n * Sent when a fine-tuning job has failed.\n */\nexport interface FineTuningJobFailedWebhookEvent {\n  /**\n   * The unique ID of the event.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) of when the fine-tuning job failed.\n   */\n  created_at: number;\n\n  /**\n   * Event data payload.\n   */\n  data: FineTuningJobFailedWebhookEvent.Data;\n\n  /**\n   * The type of the event. Always `fine_tuning.job.failed`.\n   */\n  type: 'fine_tuning.job.failed';\n\n  /**\n   * The object of the event. Always `event`.\n   */\n  object?: 'event';\n}\n\nexport namespace FineTuningJobFailedWebhookEvent {\n  /**\n   * Event data payload.\n   */\n  export interface Data {\n    /**\n     * The unique ID of the fine-tuning job.\n     */\n    id: string;\n  }\n}\n\n/**\n * Sent when a fine-tuning job has succeeded.\n */\nexport interface FineTuningJobSucceededWebhookEvent {\n  /**\n   * The unique ID of the event.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) of when the fine-tuning job succeeded.\n   */\n  created_at: number;\n\n  /**\n   * Event data payload.\n   */\n  data: FineTuningJobSucceededWebhookEvent.Data;\n\n  /**\n   * The type of the event. Always `fine_tuning.job.succeeded`.\n   */\n  type: 'fine_tuning.job.succeeded';\n\n  /**\n   * The object of the event. Always `event`.\n   */\n  object?: 'event';\n}\n\nexport namespace FineTuningJobSucceededWebhookEvent {\n  /**\n   * Event data payload.\n   */\n  export interface Data {\n    /**\n     * The unique ID of the fine-tuning job.\n     */\n    id: string;\n  }\n}\n\n/**\n * Sent when Realtime API Receives a incoming SIP call.\n */\nexport interface RealtimeCallIncomingWebhookEvent {\n  /**\n   * The unique ID of the event.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) of when the model response was completed.\n   */\n  created_at: number;\n\n  /**\n   * Event data payload.\n   */\n  data: RealtimeCallIncomingWebhookEvent.Data;\n\n  /**\n   * The type of the event. Always `realtime.call.incoming`.\n   */\n  type: 'realtime.call.incoming';\n\n  /**\n   * The object of the event. Always `event`.\n   */\n  object?: 'event';\n}\n\nexport namespace RealtimeCallIncomingWebhookEvent {\n  /**\n   * Event data payload.\n   */\n  export interface Data {\n    /**\n     * The unique ID of this call.\n     */\n    call_id: string;\n\n    /**\n     * Headers from the SIP Invite.\n     */\n    sip_headers: Array<Data.SipHeader>;\n  }\n\n  export namespace Data {\n    /**\n     * A header from the SIP Invite.\n     */\n    export interface SipHeader {\n      /**\n       * Name of the SIP Header.\n       */\n      name: string;\n\n      /**\n       * Value of the SIP Header.\n       */\n      value: string;\n    }\n  }\n}\n\n/**\n * Sent when a background response has been cancelled.\n */\nexport interface ResponseCancelledWebhookEvent {\n  /**\n   * The unique ID of the event.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) of when the model response was cancelled.\n   */\n  created_at: number;\n\n  /**\n   * Event data payload.\n   */\n  data: ResponseCancelledWebhookEvent.Data;\n\n  /**\n   * The type of the event. Always `response.cancelled`.\n   */\n  type: 'response.cancelled';\n\n  /**\n   * The object of the event. Always `event`.\n   */\n  object?: 'event';\n}\n\nexport namespace ResponseCancelledWebhookEvent {\n  /**\n   * Event data payload.\n   */\n  export interface Data {\n    /**\n     * The unique ID of the model response.\n     */\n    id: string;\n  }\n}\n\n/**\n * Sent when a background response has been completed.\n */\nexport interface ResponseCompletedWebhookEvent {\n  /**\n   * The unique ID of the event.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) of when the model response was completed.\n   */\n  created_at: number;\n\n  /**\n   * Event data payload.\n   */\n  data: ResponseCompletedWebhookEvent.Data;\n\n  /**\n   * The type of the event. Always `response.completed`.\n   */\n  type: 'response.completed';\n\n  /**\n   * The object of the event. Always `event`.\n   */\n  object?: 'event';\n}\n\nexport namespace ResponseCompletedWebhookEvent {\n  /**\n   * Event data payload.\n   */\n  export interface Data {\n    /**\n     * The unique ID of the model response.\n     */\n    id: string;\n  }\n}\n\n/**\n * Sent when a background response has failed.\n */\nexport interface ResponseFailedWebhookEvent {\n  /**\n   * The unique ID of the event.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) of when the model response failed.\n   */\n  created_at: number;\n\n  /**\n   * Event data payload.\n   */\n  data: ResponseFailedWebhookEvent.Data;\n\n  /**\n   * The type of the event. Always `response.failed`.\n   */\n  type: 'response.failed';\n\n  /**\n   * The object of the event. Always `event`.\n   */\n  object?: 'event';\n}\n\nexport namespace ResponseFailedWebhookEvent {\n  /**\n   * Event data payload.\n   */\n  export interface Data {\n    /**\n     * The unique ID of the model response.\n     */\n    id: string;\n  }\n}\n\n/**\n * Sent when a background response has been interrupted.\n */\nexport interface ResponseIncompleteWebhookEvent {\n  /**\n   * The unique ID of the event.\n   */\n  id: string;\n\n  /**\n   * The Unix timestamp (in seconds) of when the model response was interrupted.\n   */\n  created_at: number;\n\n  /**\n   * Event data payload.\n   */\n  data: ResponseIncompleteWebhookEvent.Data;\n\n  /**\n   * The type of the event. Always `response.incomplete`.\n   */\n  type: 'response.incomplete';\n\n  /**\n   * The object of the event. Always `event`.\n   */\n  object?: 'event';\n}\n\nexport namespace ResponseIncompleteWebhookEvent {\n  /**\n   * Event data payload.\n   */\n  export interface Data {\n    /**\n     * The unique ID of the model response.\n     */\n    id: string;\n  }\n}\n\n/**\n * Sent when a batch API request has been cancelled.\n */\nexport type UnwrapWebhookEvent =\n  | BatchCancelledWebhookEvent\n  | BatchCompletedWebhookEvent\n  | BatchExpiredWebhookEvent\n  | BatchFailedWebhookEvent\n  | EvalRunCanceledWebhookEvent\n  | EvalRunFailedWebhookEvent\n  | EvalRunSucceededWebhookEvent\n  | FineTuningJobCancelledWebhookEvent\n  | FineTuningJobFailedWebhookEvent\n  | FineTuningJobSucceededWebhookEvent\n  | RealtimeCallIncomingWebhookEvent\n  | ResponseCancelledWebhookEvent\n  | ResponseCompletedWebhookEvent\n  | ResponseFailedWebhookEvent\n  | ResponseIncompleteWebhookEvent;\n\nexport declare namespace Webhooks {\n  export {\n    type BatchCancelledWebhookEvent as BatchCancelledWebhookEvent,\n    type BatchCompletedWebhookEvent as BatchCompletedWebhookEvent,\n    type BatchExpiredWebhookEvent as BatchExpiredWebhookEvent,\n    type BatchFailedWebhookEvent as BatchFailedWebhookEvent,\n    type EvalRunCanceledWebhookEvent as EvalRunCanceledWebhookEvent,\n    type EvalRunFailedWebhookEvent as EvalRunFailedWebhookEvent,\n    type EvalRunSucceededWebhookEvent as EvalRunSucceededWebhookEvent,\n    type FineTuningJobCancelledWebhookEvent as FineTuningJobCancelledWebhookEvent,\n    type FineTuningJobFailedWebhookEvent as FineTuningJobFailedWebhookEvent,\n    type FineTuningJobSucceededWebhookEvent as FineTuningJobSucceededWebhookEvent,\n    type RealtimeCallIncomingWebhookEvent as RealtimeCallIncomingWebhookEvent,\n    type ResponseCancelledWebhookEvent as ResponseCancelledWebhookEvent,\n    type ResponseCompletedWebhookEvent as ResponseCompletedWebhookEvent,\n    type ResponseFailedWebhookEvent as ResponseFailedWebhookEvent,\n    type ResponseIncompleteWebhookEvent as ResponseIncompleteWebhookEvent,\n    type UnwrapWebhookEvent as UnwrapWebhookEvent,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}