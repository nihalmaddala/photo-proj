{"ast":null,"code":"import { ReadableStreamFrom } from \"./shims.mjs\";\nexport const checkFileSupport = () => {\n  if (typeof File === 'undefined') {\n    const {\n      process\n    } = globalThis;\n    const isOldNode = typeof process?.versions?.node === 'string' && parseInt(process.versions.node.split('.')) < 20;\n    throw new Error('`File` is not defined as a global, which is required for file uploads.' + (isOldNode ? \" Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`.\" : ''));\n  }\n};\n/**\n * Construct a `File` instance. This is used to ensure a helpful error is thrown\n * for environments that don't define a global `File` yet.\n */\nexport function makeFile(fileBits, fileName, options) {\n  checkFileSupport();\n  return new File(fileBits, fileName ?? 'unknown_file', options);\n}\nexport function getName(value) {\n  return (typeof value === 'object' && value !== null && ('name' in value && value.name && String(value.name) || 'url' in value && value.url && String(value.url) || 'filename' in value && value.filename && String(value.filename) || 'path' in value && value.path && String(value.path)) || '').split(/[\\\\/]/).pop() || undefined;\n}\nexport const isAsyncIterable = value => value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\n/**\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n * Otherwise returns the request as is.\n */\nexport const maybeMultipartFormRequestOptions = async (opts, fetch) => {\n  if (!hasUploadableValue(opts.body)) return opts;\n  return {\n    ...opts,\n    body: await createForm(opts.body, fetch)\n  };\n};\nexport const multipartFormRequestOptions = async (opts, fetch) => {\n  return {\n    ...opts,\n    body: await createForm(opts.body, fetch)\n  };\n};\nconst supportsFormDataMap = /* @__PURE__ */new WeakMap();\n/**\n * node-fetch doesn't support the global FormData object in recent node versions. Instead of sending\n * properly-encoded form data, it just stringifies the object, resulting in a request body of \"[object FormData]\".\n * This function detects if the fetch function provided supports the global FormData object to avoid\n * confusing error messages later on.\n */\nfunction supportsFormData(fetchObject) {\n  const fetch = typeof fetchObject === 'function' ? fetchObject : fetchObject.fetch;\n  const cached = supportsFormDataMap.get(fetch);\n  if (cached) return cached;\n  const promise = (async () => {\n    try {\n      const FetchResponse = 'Response' in fetch ? fetch.Response : (await fetch('data:,')).constructor;\n      const data = new FormData();\n      if (data.toString() === (await new FetchResponse(data).text())) {\n        return false;\n      }\n      return true;\n    } catch {\n      // avoid false negatives\n      return true;\n    }\n  })();\n  supportsFormDataMap.set(fetch, promise);\n  return promise;\n}\nexport const createForm = async (body, fetch) => {\n  if (!(await supportsFormData(fetch))) {\n    throw new TypeError('The provided fetch function does not support file uploads with the current global FormData class.');\n  }\n  const form = new FormData();\n  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\n  return form;\n};\n// We check for Blob not File because Bun.File doesn't inherit from File,\n// but they both inherit from Blob and have a `name` property at runtime.\nconst isNamedBlob = value => value instanceof Blob && 'name' in value;\nconst isUploadable = value => typeof value === 'object' && value !== null && (value instanceof Response || isAsyncIterable(value) || isNamedBlob(value));\nconst hasUploadableValue = value => {\n  if (isUploadable(value)) return true;\n  if (Array.isArray(value)) return value.some(hasUploadableValue);\n  if (value && typeof value === 'object') {\n    for (const k in value) {\n      if (hasUploadableValue(value[k])) return true;\n    }\n  }\n  return false;\n};\nconst addFormValue = async (form, key, value) => {\n  if (value === undefined) return;\n  if (value == null) {\n    throw new TypeError(`Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`);\n  }\n  // TODO: make nested formats configurable\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n    form.append(key, String(value));\n  } else if (value instanceof Response) {\n    form.append(key, makeFile([await value.blob()], getName(value)));\n  } else if (isAsyncIterable(value)) {\n    form.append(key, makeFile([await new Response(ReadableStreamFrom(value)).blob()], getName(value)));\n  } else if (isNamedBlob(value)) {\n    form.append(key, value, getName(value));\n  } else if (Array.isArray(value)) {\n    await Promise.all(value.map(entry => addFormValue(form, key + '[]', entry)));\n  } else if (typeof value === 'object') {\n    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));\n  } else {\n    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);\n  }\n};","map":{"version":3,"names":["ReadableStreamFrom","checkFileSupport","File","process","globalThis","isOldNode","versions","node","parseInt","split","Error","makeFile","fileBits","fileName","options","getName","value","name","String","url","filename","path","pop","undefined","isAsyncIterable","Symbol","asyncIterator","maybeMultipartFormRequestOptions","opts","fetch","hasUploadableValue","body","createForm","multipartFormRequestOptions","supportsFormDataMap","WeakMap","supportsFormData","fetchObject","cached","get","promise","FetchResponse","Response","constructor","data","FormData","toString","text","set","TypeError","form","Promise","all","Object","entries","map","key","addFormValue","isNamedBlob","Blob","isUploadable","Array","isArray","some","k","append","blob","entry","prop"],"sources":["/Users/nihalmaddala/photo-proj/node_modules/openai/src/internal/uploads.ts"],"sourcesContent":["import { type RequestOptions } from './request-options';\nimport type { FilePropertyBag, Fetch } from './builtin-types';\nimport type { OpenAI } from '../client';\nimport { ReadableStreamFrom } from './shims';\n\nexport type BlobPart = string | ArrayBuffer | ArrayBufferView | Blob | DataView;\ntype FsReadStream = AsyncIterable<Uint8Array> & { path: string | { toString(): string } };\n\n// https://github.com/oven-sh/bun/issues/5980\ninterface BunFile extends Blob {\n  readonly name?: string | undefined;\n}\n\nexport const checkFileSupport = () => {\n  if (typeof File === 'undefined') {\n    const { process } = globalThis as any;\n    const isOldNode =\n      typeof process?.versions?.node === 'string' && parseInt(process.versions.node.split('.')) < 20;\n    throw new Error(\n      '`File` is not defined as a global, which is required for file uploads.' +\n        (isOldNode ?\n          \" Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`.\"\n        : ''),\n    );\n  }\n};\n\n/**\n * Typically, this is a native \"File\" class.\n *\n * We provide the {@link toFile} utility to convert a variety of objects\n * into the File class.\n *\n * For convenience, you can also pass a fetch Response, or in Node,\n * the result of fs.createReadStream().\n */\nexport type Uploadable = File | Response | FsReadStream | BunFile;\n\n/**\n * Construct a `File` instance. This is used to ensure a helpful error is thrown\n * for environments that don't define a global `File` yet.\n */\nexport function makeFile(\n  fileBits: BlobPart[],\n  fileName: string | undefined,\n  options?: FilePropertyBag,\n): File {\n  checkFileSupport();\n  return new File(fileBits as any, fileName ?? 'unknown_file', options);\n}\n\nexport function getName(value: any): string | undefined {\n  return (\n    (\n      (typeof value === 'object' &&\n        value !== null &&\n        (('name' in value && value.name && String(value.name)) ||\n          ('url' in value && value.url && String(value.url)) ||\n          ('filename' in value && value.filename && String(value.filename)) ||\n          ('path' in value && value.path && String(value.path)))) ||\n      ''\n    )\n      .split(/[\\\\/]/)\n      .pop() || undefined\n  );\n}\n\nexport const isAsyncIterable = (value: any): value is AsyncIterable<any> =>\n  value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\n\n/**\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n * Otherwise returns the request as is.\n */\nexport const maybeMultipartFormRequestOptions = async (\n  opts: RequestOptions,\n  fetch: OpenAI | Fetch,\n): Promise<RequestOptions> => {\n  if (!hasUploadableValue(opts.body)) return opts;\n\n  return { ...opts, body: await createForm(opts.body, fetch) };\n};\n\ntype MultipartFormRequestOptions = Omit<RequestOptions, 'body'> & { body: unknown };\n\nexport const multipartFormRequestOptions = async (\n  opts: MultipartFormRequestOptions,\n  fetch: OpenAI | Fetch,\n): Promise<RequestOptions> => {\n  return { ...opts, body: await createForm(opts.body, fetch) };\n};\n\nconst supportsFormDataMap = /* @__PURE__ */ new WeakMap<Fetch, Promise<boolean>>();\n\n/**\n * node-fetch doesn't support the global FormData object in recent node versions. Instead of sending\n * properly-encoded form data, it just stringifies the object, resulting in a request body of \"[object FormData]\".\n * This function detects if the fetch function provided supports the global FormData object to avoid\n * confusing error messages later on.\n */\nfunction supportsFormData(fetchObject: OpenAI | Fetch): Promise<boolean> {\n  const fetch: Fetch = typeof fetchObject === 'function' ? fetchObject : (fetchObject as any).fetch;\n  const cached = supportsFormDataMap.get(fetch);\n  if (cached) return cached;\n  const promise = (async () => {\n    try {\n      const FetchResponse = (\n        'Response' in fetch ?\n          fetch.Response\n        : (await fetch('data:,')).constructor) as typeof Response;\n      const data = new FormData();\n      if (data.toString() === (await new FetchResponse(data).text())) {\n        return false;\n      }\n      return true;\n    } catch {\n      // avoid false negatives\n      return true;\n    }\n  })();\n  supportsFormDataMap.set(fetch, promise);\n  return promise;\n}\n\nexport const createForm = async <T = Record<string, unknown>>(\n  body: T | undefined,\n  fetch: OpenAI | Fetch,\n): Promise<FormData> => {\n  if (!(await supportsFormData(fetch))) {\n    throw new TypeError(\n      'The provided fetch function does not support file uploads with the current global FormData class.',\n    );\n  }\n  const form = new FormData();\n  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\n  return form;\n};\n\n// We check for Blob not File because Bun.File doesn't inherit from File,\n// but they both inherit from Blob and have a `name` property at runtime.\nconst isNamedBlob = (value: unknown) => value instanceof Blob && 'name' in value;\n\nconst isUploadable = (value: unknown) =>\n  typeof value === 'object' &&\n  value !== null &&\n  (value instanceof Response || isAsyncIterable(value) || isNamedBlob(value));\n\nconst hasUploadableValue = (value: unknown): boolean => {\n  if (isUploadable(value)) return true;\n  if (Array.isArray(value)) return value.some(hasUploadableValue);\n  if (value && typeof value === 'object') {\n    for (const k in value) {\n      if (hasUploadableValue((value as any)[k])) return true;\n    }\n  }\n  return false;\n};\n\nconst addFormValue = async (form: FormData, key: string, value: unknown): Promise<void> => {\n  if (value === undefined) return;\n  if (value == null) {\n    throw new TypeError(\n      `Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`,\n    );\n  }\n\n  // TODO: make nested formats configurable\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n    form.append(key, String(value));\n  } else if (value instanceof Response) {\n    form.append(key, makeFile([await value.blob()], getName(value)));\n  } else if (isAsyncIterable(value)) {\n    form.append(key, makeFile([await new Response(ReadableStreamFrom(value)).blob()], getName(value)));\n  } else if (isNamedBlob(value)) {\n    form.append(key, value, getName(value));\n  } else if (Array.isArray(value)) {\n    await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));\n  } else if (typeof value === 'object') {\n    await Promise.all(\n      Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)),\n    );\n  } else {\n    throw new TypeError(\n      `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`,\n    );\n  }\n};\n"],"mappings":"SAGSA,kBAAkB,QAAE;AAU7B,OAAO,MAAMC,gBAAgB,GAAGA,CAAA,KAAK;EACnC,IAAI,OAAOC,IAAI,KAAK,WAAW,EAAE;IAC/B,MAAM;MAAEC;IAAO,CAAE,GAAGC,UAAiB;IACrC,MAAMC,SAAS,GACb,OAAOF,OAAO,EAAEG,QAAQ,EAAEC,IAAI,KAAK,QAAQ,IAAIC,QAAQ,CAACL,OAAO,CAACG,QAAQ,CAACC,IAAI,CAACE,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE;IAChG,MAAM,IAAIC,KAAK,CACb,wEAAwE,IACrEL,SAAS,GACR,4FAA4F,GAC5F,EAAE,CAAC,CACR;EACH;AACF,CAAC;AAaD;;;;AAIA,OAAM,SAAUM,QAAQA,CACtBC,QAAoB,EACpBC,QAA4B,EAC5BC,OAAyB;EAEzBb,gBAAgB,EAAE;EAClB,OAAO,IAAIC,IAAI,CAACU,QAAe,EAAEC,QAAQ,IAAI,cAAc,EAAEC,OAAO,CAAC;AACvE;AAEA,OAAM,SAAUC,OAAOA,CAACC,KAAU;EAChC,OACE,CACG,OAAOA,KAAK,KAAK,QAAQ,IACxBA,KAAK,KAAK,IAAI,KACZ,MAAM,IAAIA,KAAK,IAAIA,KAAK,CAACC,IAAI,IAAIC,MAAM,CAACF,KAAK,CAACC,IAAI,CAAC,IAClD,KAAK,IAAID,KAAK,IAAIA,KAAK,CAACG,GAAG,IAAID,MAAM,CAACF,KAAK,CAACG,GAAG,CAAE,IACjD,UAAU,IAAIH,KAAK,IAAIA,KAAK,CAACI,QAAQ,IAAIF,MAAM,CAACF,KAAK,CAACI,QAAQ,CAAE,IAChE,MAAM,IAAIJ,KAAK,IAAIA,KAAK,CAACK,IAAI,IAAIH,MAAM,CAACF,KAAK,CAACK,IAAI,CAAE,CAAC,IAC1D,EAAE,EAEDZ,KAAK,CAAC,OAAO,CAAC,CACda,GAAG,EAAE,IAAIC,SAAS;AAEzB;AAEA,OAAO,MAAMC,eAAe,GAAIR,KAAU,IACxCA,KAAK,IAAI,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,CAACS,MAAM,CAACC,aAAa,CAAC,KAAK,UAAU;AAEjG;;;;AAIA,OAAO,MAAMC,gCAAgC,GAAG,MAAAA,CAC9CC,IAAoB,EACpBC,KAAqB,KACM;EAC3B,IAAI,CAACC,kBAAkB,CAACF,IAAI,CAACG,IAAI,CAAC,EAAE,OAAOH,IAAI;EAE/C,OAAO;IAAE,GAAGA,IAAI;IAAEG,IAAI,EAAE,MAAMC,UAAU,CAACJ,IAAI,CAACG,IAAI,EAAEF,KAAK;EAAC,CAAE;AAC9D,CAAC;AAID,OAAO,MAAMI,2BAA2B,GAAG,MAAAA,CACzCL,IAAiC,EACjCC,KAAqB,KACM;EAC3B,OAAO;IAAE,GAAGD,IAAI;IAAEG,IAAI,EAAE,MAAMC,UAAU,CAACJ,IAAI,CAACG,IAAI,EAAEF,KAAK;EAAC,CAAE;AAC9D,CAAC;AAED,MAAMK,mBAAmB,GAAG,eAAgB,IAAIC,OAAO,EAA2B;AAElF;;;;;;AAMA,SAASC,gBAAgBA,CAACC,WAA2B;EACnD,MAAMR,KAAK,GAAU,OAAOQ,WAAW,KAAK,UAAU,GAAGA,WAAW,GAAIA,WAAmB,CAACR,KAAK;EACjG,MAAMS,MAAM,GAAGJ,mBAAmB,CAACK,GAAG,CAACV,KAAK,CAAC;EAC7C,IAAIS,MAAM,EAAE,OAAOA,MAAM;EACzB,MAAME,OAAO,GAAG,CAAC,YAAW;IAC1B,IAAI;MACF,MAAMC,aAAa,GACjB,UAAU,IAAIZ,KAAK,GACjBA,KAAK,CAACa,QAAQ,GACd,CAAC,MAAMb,KAAK,CAAC,QAAQ,CAAC,EAAEc,WAA+B;MAC3D,MAAMC,IAAI,GAAG,IAAIC,QAAQ,EAAE;MAC3B,IAAID,IAAI,CAACE,QAAQ,EAAE,MAAM,MAAM,IAAIL,aAAa,CAACG,IAAI,CAAC,CAACG,IAAI,EAAE,CAAC,EAAE;QAC9D,OAAO,KAAK;MACd;MACA,OAAO,IAAI;IACb,CAAC,CAAC,MAAM;MACN;MACA,OAAO,IAAI;IACb;EACF,CAAC,EAAC,CAAE;EACJb,mBAAmB,CAACc,GAAG,CAACnB,KAAK,EAAEW,OAAO,CAAC;EACvC,OAAOA,OAAO;AAChB;AAEA,OAAO,MAAMR,UAAU,GAAG,MAAAA,CACxBD,IAAmB,EACnBF,KAAqB,KACA;EACrB,IAAI,EAAE,MAAMO,gBAAgB,CAACP,KAAK,CAAC,CAAC,EAAE;IACpC,MAAM,IAAIoB,SAAS,CACjB,mGAAmG,CACpG;EACH;EACA,MAAMC,IAAI,GAAG,IAAIL,QAAQ,EAAE;EAC3B,MAAMM,OAAO,CAACC,GAAG,CAACC,MAAM,CAACC,OAAO,CAACvB,IAAI,IAAI,EAAE,CAAC,CAACwB,GAAG,CAAC,CAAC,CAACC,GAAG,EAAExC,KAAK,CAAC,KAAKyC,YAAY,CAACP,IAAI,EAAEM,GAAG,EAAExC,KAAK,CAAC,CAAC,CAAC;EACnG,OAAOkC,IAAI;AACb,CAAC;AAED;AACA;AACA,MAAMQ,WAAW,GAAI1C,KAAc,IAAKA,KAAK,YAAY2C,IAAI,IAAI,MAAM,IAAI3C,KAAK;AAEhF,MAAM4C,YAAY,GAAI5C,KAAc,IAClC,OAAOA,KAAK,KAAK,QAAQ,IACzBA,KAAK,KAAK,IAAI,KACbA,KAAK,YAAY0B,QAAQ,IAAIlB,eAAe,CAACR,KAAK,CAAC,IAAI0C,WAAW,CAAC1C,KAAK,CAAC,CAAC;AAE7E,MAAMc,kBAAkB,GAAId,KAAc,IAAa;EACrD,IAAI4C,YAAY,CAAC5C,KAAK,CAAC,EAAE,OAAO,IAAI;EACpC,IAAI6C,KAAK,CAACC,OAAO,CAAC9C,KAAK,CAAC,EAAE,OAAOA,KAAK,CAAC+C,IAAI,CAACjC,kBAAkB,CAAC;EAC/D,IAAId,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IACtC,KAAK,MAAMgD,CAAC,IAAIhD,KAAK,EAAE;MACrB,IAAIc,kBAAkB,CAAEd,KAAa,CAACgD,CAAC,CAAC,CAAC,EAAE,OAAO,IAAI;IACxD;EACF;EACA,OAAO,KAAK;AACd,CAAC;AAED,MAAMP,YAAY,GAAG,MAAAA,CAAOP,IAAc,EAAEM,GAAW,EAAExC,KAAc,KAAmB;EACxF,IAAIA,KAAK,KAAKO,SAAS,EAAE;EACzB,IAAIP,KAAK,IAAI,IAAI,EAAE;IACjB,MAAM,IAAIiC,SAAS,CACjB,sBAAsBO,GAAG,6DAA6D,CACvF;EACH;EAEA;EACA,IAAI,OAAOxC,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,KAAK,SAAS,EAAE;IACxFkC,IAAI,CAACe,MAAM,CAACT,GAAG,EAAEtC,MAAM,CAACF,KAAK,CAAC,CAAC;EACjC,CAAC,MAAM,IAAIA,KAAK,YAAY0B,QAAQ,EAAE;IACpCQ,IAAI,CAACe,MAAM,CAACT,GAAG,EAAE7C,QAAQ,CAAC,CAAC,MAAMK,KAAK,CAACkD,IAAI,EAAE,CAAC,EAAEnD,OAAO,CAACC,KAAK,CAAC,CAAC,CAAC;EAClE,CAAC,MAAM,IAAIQ,eAAe,CAACR,KAAK,CAAC,EAAE;IACjCkC,IAAI,CAACe,MAAM,CAACT,GAAG,EAAE7C,QAAQ,CAAC,CAAC,MAAM,IAAI+B,QAAQ,CAAC1C,kBAAkB,CAACgB,KAAK,CAAC,CAAC,CAACkD,IAAI,EAAE,CAAC,EAAEnD,OAAO,CAACC,KAAK,CAAC,CAAC,CAAC;EACpG,CAAC,MAAM,IAAI0C,WAAW,CAAC1C,KAAK,CAAC,EAAE;IAC7BkC,IAAI,CAACe,MAAM,CAACT,GAAG,EAAExC,KAAK,EAAED,OAAO,CAACC,KAAK,CAAC,CAAC;EACzC,CAAC,MAAM,IAAI6C,KAAK,CAACC,OAAO,CAAC9C,KAAK,CAAC,EAAE;IAC/B,MAAMmC,OAAO,CAACC,GAAG,CAACpC,KAAK,CAACuC,GAAG,CAAEY,KAAK,IAAKV,YAAY,CAACP,IAAI,EAAEM,GAAG,GAAG,IAAI,EAAEW,KAAK,CAAC,CAAC,CAAC;EAChF,CAAC,MAAM,IAAI,OAAOnD,KAAK,KAAK,QAAQ,EAAE;IACpC,MAAMmC,OAAO,CAACC,GAAG,CACfC,MAAM,CAACC,OAAO,CAACtC,KAAK,CAAC,CAACuC,GAAG,CAAC,CAAC,CAACtC,IAAI,EAAEmD,IAAI,CAAC,KAAKX,YAAY,CAACP,IAAI,EAAE,GAAGM,GAAG,IAAIvC,IAAI,GAAG,EAAEmD,IAAI,CAAC,CAAC,CACzF;EACH,CAAC,MAAM;IACL,MAAM,IAAInB,SAAS,CACjB,wGAAwGjC,KAAK,UAAU,CACxH;EACH;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}