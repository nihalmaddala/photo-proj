{"ast":null,"code":"import { getName, makeFile, isAsyncIterable } from \"./uploads.mjs\";\nimport { checkFileSupport } from \"./uploads.mjs\";\n/**\n * This check adds the arrayBuffer() method type because it is available and used at runtime\n */\nconst isBlobLike = value => value != null && typeof value === 'object' && typeof value.size === 'number' && typeof value.type === 'string' && typeof value.text === 'function' && typeof value.slice === 'function' && typeof value.arrayBuffer === 'function';\n/**\n * This check adds the arrayBuffer() method type because it is available and used at runtime\n */\nconst isFileLike = value => value != null && typeof value === 'object' && typeof value.name === 'string' && typeof value.lastModified === 'number' && isBlobLike(value);\nconst isResponseLike = value => value != null && typeof value === 'object' && typeof value.url === 'string' && typeof value.blob === 'function';\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\nexport async function toFile(value, name, options) {\n  checkFileSupport();\n  // If it's a promise, resolve it.\n  value = await value;\n  // If we've been given a `File` we don't need to do anything\n  if (isFileLike(value)) {\n    if (value instanceof File) {\n      return value;\n    }\n    return makeFile([await value.arrayBuffer()], value.name);\n  }\n  if (isResponseLike(value)) {\n    const blob = await value.blob();\n    name || (name = new URL(value.url).pathname.split(/[\\\\/]/).pop());\n    return makeFile(await getBytes(blob), name, options);\n  }\n  const parts = await getBytes(value);\n  name || (name = getName(value));\n  if (!options?.type) {\n    const type = parts.find(part => typeof part === 'object' && 'type' in part && part.type);\n    if (typeof type === 'string') {\n      options = {\n        ...options,\n        type\n      };\n    }\n  }\n  return makeFile(parts, name, options);\n}\nasync function getBytes(value) {\n  let parts = [];\n  if (typeof value === 'string' || ArrayBuffer.isView(value) ||\n  // includes Uint8Array, Buffer, etc.\n  value instanceof ArrayBuffer) {\n    parts.push(value);\n  } else if (isBlobLike(value)) {\n    parts.push(value instanceof Blob ? value : await value.arrayBuffer());\n  } else if (isAsyncIterable(value) // includes Readable, ReadableStream, etc.\n  ) {\n    for await (const chunk of value) {\n      parts.push(...(await getBytes(chunk))); // TODO, consider validating?\n    }\n  } else {\n    const constructor = value?.constructor?.name;\n    throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ''}${propsForError(value)}`);\n  }\n  return parts;\n}\nfunction propsForError(value) {\n  if (typeof value !== 'object' || value === null) return '';\n  const props = Object.getOwnPropertyNames(value);\n  return `; props: [${props.map(p => `\"${p}\"`).join(', ')}]`;\n}","map":{"version":3,"names":["getName","makeFile","isAsyncIterable","checkFileSupport","isBlobLike","value","size","type","text","slice","arrayBuffer","isFileLike","name","lastModified","isResponseLike","url","blob","toFile","options","File","URL","pathname","split","pop","getBytes","parts","find","part","ArrayBuffer","isView","push","Blob","chunk","constructor","Error","propsForError","props","Object","getOwnPropertyNames","map","p","join"],"sources":["/Users/nihalmaddala/photo-proj/node_modules/openai/src/internal/to-file.ts"],"sourcesContent":["import { BlobPart, getName, makeFile, isAsyncIterable } from './uploads';\nimport type { FilePropertyBag } from './builtin-types';\nimport { checkFileSupport } from './uploads';\n\ntype BlobLikePart = string | ArrayBuffer | ArrayBufferView | BlobLike | DataView;\n\n/**\n * Intended to match DOM Blob, node-fetch Blob, node:buffer Blob, etc.\n * Don't add arrayBuffer here, node-fetch doesn't have it\n */\ninterface BlobLike {\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/size) */\n  readonly size: number;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/type) */\n  readonly type: string;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/text) */\n  text(): Promise<string>;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/slice) */\n  slice(start?: number, end?: number): BlobLike;\n}\n\n/**\n * This check adds the arrayBuffer() method type because it is available and used at runtime\n */\nconst isBlobLike = (value: any): value is BlobLike & { arrayBuffer(): Promise<ArrayBuffer> } =>\n  value != null &&\n  typeof value === 'object' &&\n  typeof value.size === 'number' &&\n  typeof value.type === 'string' &&\n  typeof value.text === 'function' &&\n  typeof value.slice === 'function' &&\n  typeof value.arrayBuffer === 'function';\n\n/**\n * Intended to match DOM File, node:buffer File, undici File, etc.\n */\ninterface FileLike extends BlobLike {\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/lastModified) */\n  readonly lastModified: number;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/name) */\n  readonly name?: string | undefined;\n}\n\n/**\n * This check adds the arrayBuffer() method type because it is available and used at runtime\n */\nconst isFileLike = (value: any): value is FileLike & { arrayBuffer(): Promise<ArrayBuffer> } =>\n  value != null &&\n  typeof value === 'object' &&\n  typeof value.name === 'string' &&\n  typeof value.lastModified === 'number' &&\n  isBlobLike(value);\n\n/**\n * Intended to match DOM Response, node-fetch Response, undici Response, etc.\n */\nexport interface ResponseLike {\n  url: string;\n  blob(): Promise<BlobLike>;\n}\n\nconst isResponseLike = (value: any): value is ResponseLike =>\n  value != null &&\n  typeof value === 'object' &&\n  typeof value.url === 'string' &&\n  typeof value.blob === 'function';\n\nexport type ToFileInput =\n  | FileLike\n  | ResponseLike\n  | Exclude<BlobLikePart, string>\n  | AsyncIterable<BlobLikePart>;\n\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\nexport async function toFile(\n  value: ToFileInput | PromiseLike<ToFileInput>,\n  name?: string | null | undefined,\n  options?: FilePropertyBag | undefined,\n): Promise<File> {\n  checkFileSupport();\n\n  // If it's a promise, resolve it.\n  value = await value;\n\n  // If we've been given a `File` we don't need to do anything\n  if (isFileLike(value)) {\n    if (value instanceof File) {\n      return value;\n    }\n    return makeFile([await value.arrayBuffer()], value.name);\n  }\n\n  if (isResponseLike(value)) {\n    const blob = await value.blob();\n    name ||= new URL(value.url).pathname.split(/[\\\\/]/).pop();\n\n    return makeFile(await getBytes(blob), name, options);\n  }\n\n  const parts = await getBytes(value);\n\n  name ||= getName(value);\n\n  if (!options?.type) {\n    const type = parts.find((part) => typeof part === 'object' && 'type' in part && part.type);\n    if (typeof type === 'string') {\n      options = { ...options, type };\n    }\n  }\n\n  return makeFile(parts, name, options);\n}\n\nasync function getBytes(value: BlobLikePart | AsyncIterable<BlobLikePart>): Promise<Array<BlobPart>> {\n  let parts: Array<BlobPart> = [];\n  if (\n    typeof value === 'string' ||\n    ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\n    value instanceof ArrayBuffer\n  ) {\n    parts.push(value);\n  } else if (isBlobLike(value)) {\n    parts.push(value instanceof Blob ? value : await value.arrayBuffer());\n  } else if (\n    isAsyncIterable(value) // includes Readable, ReadableStream, etc.\n  ) {\n    for await (const chunk of value) {\n      parts.push(...(await getBytes(chunk as BlobLikePart))); // TODO, consider validating?\n    }\n  } else {\n    const constructor = value?.constructor?.name;\n    throw new Error(\n      `Unexpected data type: ${typeof value}${\n        constructor ? `; constructor: ${constructor}` : ''\n      }${propsForError(value)}`,\n    );\n  }\n\n  return parts;\n}\n\nfunction propsForError(value: unknown): string {\n  if (typeof value !== 'object' || value === null) return '';\n  const props = Object.getOwnPropertyNames(value);\n  return `; props: [${props.map((p) => `\"${p}\"`).join(', ')}]`;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}