{"ast":null,"code":"// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nexport function getDefaultFetch() {\n  if (typeof fetch !== 'undefined') {\n    return fetch;\n  }\n  throw new Error('`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`');\n}\nexport function makeReadableStream(...args) {\n  const ReadableStream = globalThis.ReadableStream;\n  if (typeof ReadableStream === 'undefined') {\n    // Note: All of the platforms / runtimes we officially support already define\n    // `ReadableStream` as a global, so this should only ever be hit on unsupported runtimes.\n    throw new Error('`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`');\n  }\n  return new ReadableStream(...args);\n}\nexport function ReadableStreamFrom(iterable) {\n  let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();\n  return makeReadableStream({\n    start() {},\n    async pull(controller) {\n      const {\n        done,\n        value\n      } = await iter.next();\n      if (done) {\n        controller.close();\n      } else {\n        controller.enqueue(value);\n      }\n    },\n    async cancel() {\n      await iter.return?.();\n    }\n  });\n}\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function ReadableStreamToAsyncIterable(stream) {\n  if (stream[Symbol.asyncIterator]) return stream;\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return {\n        done: true,\n        value: undefined\n      };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n}\n/**\n * Cancels a ReadableStream we don't need to consume.\n * See https://undici.nodejs.org/#/?id=garbage-collection\n */\nexport async function CancelReadableStream(stream) {\n  if (stream === null || typeof stream !== 'object') return;\n  if (stream[Symbol.asyncIterator]) {\n    await stream[Symbol.asyncIterator]().return?.();\n    return;\n  }\n  const reader = stream.getReader();\n  const cancelPromise = reader.cancel();\n  reader.releaseLock();\n  await cancelPromise;\n}","map":{"version":3,"names":["getDefaultFetch","fetch","Error","makeReadableStream","args","ReadableStream","globalThis","ReadableStreamFrom","iterable","iter","Symbol","asyncIterator","iterator","start","pull","controller","done","value","next","close","enqueue","cancel","return","ReadableStreamToAsyncIterable","stream","reader","getReader","result","read","releaseLock","e","cancelPromise","undefined","CancelReadableStream"],"sources":["/Users/nihalmaddala/photo-proj/node_modules/openai/src/internal/shims.ts"],"sourcesContent":["// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\n/**\n * This module provides internal shims and utility functions for environments where certain Node.js or global types may not be available.\n *\n * These are used to ensure we can provide a consistent behaviour between different JavaScript environments and good error\n * messages in cases where an environment isn't fully supported.\n */\n\nimport type { Fetch } from './builtin-types';\nimport type { ReadableStream } from './shim-types';\n\nexport function getDefaultFetch(): Fetch {\n  if (typeof fetch !== 'undefined') {\n    return fetch as any;\n  }\n\n  throw new Error(\n    '`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`',\n  );\n}\n\ntype ReadableStreamArgs = ConstructorParameters<typeof ReadableStream>;\n\nexport function makeReadableStream(...args: ReadableStreamArgs): ReadableStream {\n  const ReadableStream = (globalThis as any).ReadableStream;\n  if (typeof ReadableStream === 'undefined') {\n    // Note: All of the platforms / runtimes we officially support already define\n    // `ReadableStream` as a global, so this should only ever be hit on unsupported runtimes.\n    throw new Error(\n      '`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`',\n    );\n  }\n\n  return new ReadableStream(...args);\n}\n\nexport function ReadableStreamFrom<T>(iterable: Iterable<T> | AsyncIterable<T>): ReadableStream<T> {\n  let iter: AsyncIterator<T> | Iterator<T> =\n    Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();\n\n  return makeReadableStream({\n    start() {},\n    async pull(controller: any) {\n      const { done, value } = await iter.next();\n      if (done) {\n        controller.close();\n      } else {\n        controller.enqueue(value);\n      }\n    },\n    async cancel() {\n      await iter.return?.();\n    },\n  });\n}\n\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function ReadableStreamToAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {\n  if (stream[Symbol.asyncIterator]) return stream;\n\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return { done: true, value: undefined };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n\n/**\n * Cancels a ReadableStream we don't need to consume.\n * See https://undici.nodejs.org/#/?id=garbage-collection\n */\nexport async function CancelReadableStream(stream: any): Promise<void> {\n  if (stream === null || typeof stream !== 'object') return;\n\n  if (stream[Symbol.asyncIterator]) {\n    await stream[Symbol.asyncIterator]().return?.();\n    return;\n  }\n\n  const reader = stream.getReader();\n  const cancelPromise = reader.cancel();\n  reader.releaseLock();\n  await cancelPromise;\n}\n"],"mappings":"AAAA;AAYA,OAAM,SAAUA,eAAeA,CAAA;EAC7B,IAAI,OAAOC,KAAK,KAAK,WAAW,EAAE;IAChC,OAAOA,KAAY;EACrB;EAEA,MAAM,IAAIC,KAAK,CACb,mJAAmJ,CACpJ;AACH;AAIA,OAAM,SAAUC,kBAAkBA,CAAC,GAAGC,IAAwB;EAC5D,MAAMC,cAAc,GAAIC,UAAkB,CAACD,cAAc;EACzD,IAAI,OAAOA,cAAc,KAAK,WAAW,EAAE;IACzC;IACA;IACA,MAAM,IAAIH,KAAK,CACb,yHAAyH,CAC1H;EACH;EAEA,OAAO,IAAIG,cAAc,CAAC,GAAGD,IAAI,CAAC;AACpC;AAEA,OAAM,SAAUG,kBAAkBA,CAAIC,QAAwC;EAC5E,IAAIC,IAAI,GACNC,MAAM,CAACC,aAAa,IAAIH,QAAQ,GAAGA,QAAQ,CAACE,MAAM,CAACC,aAAa,CAAC,EAAE,GAAGH,QAAQ,CAACE,MAAM,CAACE,QAAQ,CAAC,EAAE;EAEnG,OAAOT,kBAAkB,CAAC;IACxBU,KAAKA,CAAA,GAAI,CAAC;IACV,MAAMC,IAAIA,CAACC,UAAe;MACxB,MAAM;QAAEC,IAAI;QAAEC;MAAK,CAAE,GAAG,MAAMR,IAAI,CAACS,IAAI,EAAE;MACzC,IAAIF,IAAI,EAAE;QACRD,UAAU,CAACI,KAAK,EAAE;MACpB,CAAC,MAAM;QACLJ,UAAU,CAACK,OAAO,CAACH,KAAK,CAAC;MAC3B;IACF,CAAC;IACD,MAAMI,MAAMA,CAAA;MACV,MAAMZ,IAAI,CAACa,MAAM,GAAE,CAAE;IACvB;GACD,CAAC;AACJ;AAEA;;;;;;AAMA,OAAM,SAAUC,6BAA6BA,CAAIC,MAAW;EAC1D,IAAIA,MAAM,CAACd,MAAM,CAACC,aAAa,CAAC,EAAE,OAAOa,MAAM;EAE/C,MAAMC,MAAM,GAAGD,MAAM,CAACE,SAAS,EAAE;EACjC,OAAO;IACL,MAAMR,IAAIA,CAAA;MACR,IAAI;QACF,MAAMS,MAAM,GAAG,MAAMF,MAAM,CAACG,IAAI,EAAE;QAClC,IAAID,MAAM,EAAEX,IAAI,EAAES,MAAM,CAACI,WAAW,EAAE,CAAC,CAAC;QACxC,OAAOF,MAAM;MACf,CAAC,CAAC,OAAOG,CAAC,EAAE;QACVL,MAAM,CAACI,WAAW,EAAE,CAAC,CAAC;QACtB,MAAMC,CAAC;MACT;IACF,CAAC;IACD,MAAMR,MAAMA,CAAA;MACV,MAAMS,aAAa,GAAGN,MAAM,CAACJ,MAAM,EAAE;MACrCI,MAAM,CAACI,WAAW,EAAE;MACpB,MAAME,aAAa;MACnB,OAAO;QAAEf,IAAI,EAAE,IAAI;QAAEC,KAAK,EAAEe;MAAS,CAAE;IACzC,CAAC;IACD,CAACtB,MAAM,CAACC,aAAa,IAAC;MACpB,OAAO,IAAI;IACb;GACD;AACH;AAEA;;;;AAIA,OAAO,eAAesB,oBAAoBA,CAACT,MAAW;EACpD,IAAIA,MAAM,KAAK,IAAI,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;EAEnD,IAAIA,MAAM,CAACd,MAAM,CAACC,aAAa,CAAC,EAAE;IAChC,MAAMa,MAAM,CAACd,MAAM,CAACC,aAAa,CAAC,EAAE,CAACW,MAAM,GAAE,CAAE;IAC/C;EACF;EAEA,MAAMG,MAAM,GAAGD,MAAM,CAACE,SAAS,EAAE;EACjC,MAAMK,aAAa,GAAGN,MAAM,CAACJ,MAAM,EAAE;EACrCI,MAAM,CAACI,WAAW,EAAE;EACpB,MAAME,aAAa;AACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}