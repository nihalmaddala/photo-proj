{"ast":null,"code":"// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nimport { isReadonlyArray } from \"./utils/values.mjs\";\nconst brand_privateNullableHeaders = /* @__PURE__ */Symbol('brand.privateNullableHeaders');\nfunction* iterateHeaders(headers) {\n  if (!headers) return;\n  if (brand_privateNullableHeaders in headers) {\n    const {\n      values,\n      nulls\n    } = headers;\n    yield* values.entries();\n    for (const name of nulls) {\n      yield [name, null];\n    }\n    return;\n  }\n  let shouldClear = false;\n  let iter;\n  if (headers instanceof Headers) {\n    iter = headers.entries();\n  } else if (isReadonlyArray(headers)) {\n    iter = headers;\n  } else {\n    shouldClear = true;\n    iter = Object.entries(headers ?? {});\n  }\n  for (let row of iter) {\n    const name = row[0];\n    if (typeof name !== 'string') throw new TypeError('expected header name to be a string');\n    const values = isReadonlyArray(row[1]) ? row[1] : [row[1]];\n    let didClear = false;\n    for (const value of values) {\n      if (value === undefined) continue;\n      // Objects keys always overwrite older headers, they never append.\n      // Yield a null to clear the header before adding the new values.\n      if (shouldClear && !didClear) {\n        didClear = true;\n        yield [name, null];\n      }\n      yield [name, value];\n    }\n  }\n}\nexport const buildHeaders = newHeaders => {\n  const targetHeaders = new Headers();\n  const nullHeaders = new Set();\n  for (const headers of newHeaders) {\n    const seenHeaders = new Set();\n    for (const [name, value] of iterateHeaders(headers)) {\n      const lowerName = name.toLowerCase();\n      if (!seenHeaders.has(lowerName)) {\n        targetHeaders.delete(name);\n        seenHeaders.add(lowerName);\n      }\n      if (value === null) {\n        targetHeaders.delete(name);\n        nullHeaders.add(lowerName);\n      } else {\n        targetHeaders.append(name, value);\n        nullHeaders.delete(lowerName);\n      }\n    }\n  }\n  return {\n    [brand_privateNullableHeaders]: true,\n    values: targetHeaders,\n    nulls: nullHeaders\n  };\n};\nexport const isEmptyHeaders = headers => {\n  for (const _ of iterateHeaders(headers)) return false;\n  return true;\n};","map":{"version":3,"names":["isReadonlyArray","brand_privateNullableHeaders","Symbol","iterateHeaders","headers","values","nulls","entries","name","shouldClear","iter","Headers","Object","row","TypeError","didClear","value","undefined","buildHeaders","newHeaders","targetHeaders","nullHeaders","Set","seenHeaders","lowerName","toLowerCase","has","delete","add","append","isEmptyHeaders","_"],"sources":["/Users/nihalmaddala/photo-proj/node_modules/openai/src/internal/headers.ts"],"sourcesContent":["// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nimport { isReadonlyArray } from './utils/values';\n\ntype HeaderValue = string | undefined | null;\nexport type HeadersLike =\n  | Headers\n  | readonly HeaderValue[][]\n  | Record<string, HeaderValue | readonly HeaderValue[]>\n  | undefined\n  | null\n  | NullableHeaders;\n\nconst brand_privateNullableHeaders = /* @__PURE__ */ Symbol('brand.privateNullableHeaders');\n\n/**\n * @internal\n * Users can pass explicit nulls to unset default headers. When we parse them\n * into a standard headers type we need to preserve that information.\n */\nexport type NullableHeaders = {\n  /** Brand check, prevent users from creating a NullableHeaders. */\n  [brand_privateNullableHeaders]: true;\n  /** Parsed headers. */\n  values: Headers;\n  /** Set of lowercase header names explicitly set to null. */\n  nulls: Set<string>;\n};\n\nfunction* iterateHeaders(headers: HeadersLike): IterableIterator<readonly [string, string | null]> {\n  if (!headers) return;\n\n  if (brand_privateNullableHeaders in headers) {\n    const { values, nulls } = headers;\n    yield* values.entries();\n    for (const name of nulls) {\n      yield [name, null];\n    }\n    return;\n  }\n\n  let shouldClear = false;\n  let iter: Iterable<readonly (HeaderValue | readonly HeaderValue[])[]>;\n  if (headers instanceof Headers) {\n    iter = headers.entries();\n  } else if (isReadonlyArray(headers)) {\n    iter = headers;\n  } else {\n    shouldClear = true;\n    iter = Object.entries(headers ?? {});\n  }\n  for (let row of iter) {\n    const name = row[0];\n    if (typeof name !== 'string') throw new TypeError('expected header name to be a string');\n    const values = isReadonlyArray(row[1]) ? row[1] : [row[1]];\n    let didClear = false;\n    for (const value of values) {\n      if (value === undefined) continue;\n\n      // Objects keys always overwrite older headers, they never append.\n      // Yield a null to clear the header before adding the new values.\n      if (shouldClear && !didClear) {\n        didClear = true;\n        yield [name, null];\n      }\n      yield [name, value];\n    }\n  }\n}\n\nexport const buildHeaders = (newHeaders: HeadersLike[]): NullableHeaders => {\n  const targetHeaders = new Headers();\n  const nullHeaders = new Set<string>();\n  for (const headers of newHeaders) {\n    const seenHeaders = new Set<string>();\n    for (const [name, value] of iterateHeaders(headers)) {\n      const lowerName = name.toLowerCase();\n      if (!seenHeaders.has(lowerName)) {\n        targetHeaders.delete(name);\n        seenHeaders.add(lowerName);\n      }\n      if (value === null) {\n        targetHeaders.delete(name);\n        nullHeaders.add(lowerName);\n      } else {\n        targetHeaders.append(name, value);\n        nullHeaders.delete(lowerName);\n      }\n    }\n  }\n  return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };\n};\n\nexport const isEmptyHeaders = (headers: HeadersLike) => {\n  for (const _ of iterateHeaders(headers)) return false;\n  return true;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}