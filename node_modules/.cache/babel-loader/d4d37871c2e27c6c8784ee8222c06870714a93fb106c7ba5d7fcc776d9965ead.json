{"ast":null,"code":"var _LineDecoder_buffer, _LineDecoder_carriageReturnIndex;\nimport { __classPrivateFieldGet, __classPrivateFieldSet } from \"../tslib.mjs\";\nimport { concatBytes, decodeUTF8, encodeUTF8 } from \"../utils/bytes.mjs\";\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nexport class LineDecoder {\n  constructor() {\n    _LineDecoder_buffer.set(this, void 0);\n    _LineDecoder_carriageReturnIndex.set(this, void 0);\n    __classPrivateFieldSet(this, _LineDecoder_buffer, new Uint8Array(), \"f\");\n    __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n  }\n  decode(chunk) {\n    if (chunk == null) {\n      return [];\n    }\n    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === 'string' ? encodeUTF8(chunk) : chunk;\n    __classPrivateFieldSet(this, _LineDecoder_buffer, concatBytes([__classPrivateFieldGet(this, _LineDecoder_buffer, \"f\"), binaryChunk]), \"f\");\n    const lines = [];\n    let patternIndex;\n    while ((patternIndex = findNewlineIndex(__classPrivateFieldGet(this, _LineDecoder_buffer, \"f\"), __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\"))) != null) {\n      if (patternIndex.carriage && __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") == null) {\n        // skip until we either get a corresponding `\\n`, a new `\\r` or nothing\n        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, \"f\");\n        continue;\n      }\n      // we got double \\r or \\rtext\\n\n      if (__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") != null && (patternIndex.index !== __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") + 1 || patternIndex.carriage)) {\n        lines.push(decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, \"f\").subarray(0, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") - 1)));\n        __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, \"f\").subarray(__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\")), \"f\");\n        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n        continue;\n      }\n      const endIndex = __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, \"f\") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;\n      const line = decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, \"f\").subarray(0, endIndex));\n      lines.push(line);\n      __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, \"f\").subarray(patternIndex.index), \"f\");\n      __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n    }\n    return lines;\n  }\n  flush() {\n    if (!__classPrivateFieldGet(this, _LineDecoder_buffer, \"f\").length) {\n      return [];\n    }\n    return this.decode('\\n');\n  }\n}\n_LineDecoder_buffer = new WeakMap(), _LineDecoder_carriageReturnIndex = new WeakMap();\n// prettier-ignore\nLineDecoder.NEWLINE_CHARS = new Set(['\\n', '\\r']);\nLineDecoder.NEWLINE_REGEXP = /\\r\\n|[\\n\\r]/g;\n/**\n * This function searches the buffer for the end patterns, (\\r or \\n)\n * and returns an object with the index preceding the matched newline and the\n * index after the newline char. `null` is returned if no new line is found.\n *\n * ```ts\n * findNewLineIndex('abc\\ndef') -> { preceding: 2, index: 3 }\n * ```\n */\nfunction findNewlineIndex(buffer, startIndex) {\n  const newline = 0x0a; // \\n\n  const carriage = 0x0d; // \\r\n  for (let i = startIndex ?? 0; i < buffer.length; i++) {\n    if (buffer[i] === newline) {\n      return {\n        preceding: i,\n        index: i + 1,\n        carriage: false\n      };\n    }\n    if (buffer[i] === carriage) {\n      return {\n        preceding: i,\n        index: i + 1,\n        carriage: true\n      };\n    }\n  }\n  return null;\n}\nexport function findDoubleNewlineIndex(buffer) {\n  // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n  // and returns the index right after the first occurrence of any pattern,\n  // or -1 if none of the patterns are found.\n  const newline = 0x0a; // \\n\n  const carriage = 0x0d; // \\r\n  for (let i = 0; i < buffer.length - 1; i++) {\n    if (buffer[i] === newline && buffer[i + 1] === newline) {\n      // \\n\\n\n      return i + 2;\n    }\n    if (buffer[i] === carriage && buffer[i + 1] === carriage) {\n      // \\r\\r\n      return i + 2;\n    }\n    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {\n      // \\r\\n\\r\\n\n      return i + 4;\n    }\n  }\n  return -1;\n}","map":{"version":3,"names":["concatBytes","decodeUTF8","encodeUTF8","LineDecoder","constructor","_LineDecoder_buffer","set","_LineDecoder_carriageReturnIndex","__classPrivateFieldSet","Uint8Array","decode","chunk","binaryChunk","ArrayBuffer","__classPrivateFieldGet","lines","patternIndex","findNewlineIndex","carriage","index","push","subarray","endIndex","preceding","line","flush","length","NEWLINE_CHARS","Set","NEWLINE_REGEXP","buffer","startIndex","newline","i","findDoubleNewlineIndex"],"sources":["/Users/nihalmaddala/photo-proj/node_modules/openai/src/internal/decoders/line.ts"],"sourcesContent":["import { concatBytes, decodeUTF8, encodeUTF8 } from '../utils/bytes';\n\nexport type Bytes = string | ArrayBuffer | Uint8Array | null | undefined;\n\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nexport class LineDecoder {\n  // prettier-ignore\n  static NEWLINE_CHARS = new Set(['\\n', '\\r']);\n  static NEWLINE_REGEXP = /\\r\\n|[\\n\\r]/g;\n\n  #buffer: Uint8Array;\n  #carriageReturnIndex: number | null;\n\n  constructor() {\n    this.#buffer = new Uint8Array();\n    this.#carriageReturnIndex = null;\n  }\n\n  decode(chunk: Bytes): string[] {\n    if (chunk == null) {\n      return [];\n    }\n\n    const binaryChunk =\n      chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n      : typeof chunk === 'string' ? encodeUTF8(chunk)\n      : chunk;\n\n    this.#buffer = concatBytes([this.#buffer, binaryChunk]);\n\n    const lines: string[] = [];\n    let patternIndex;\n    while ((patternIndex = findNewlineIndex(this.#buffer, this.#carriageReturnIndex)) != null) {\n      if (patternIndex.carriage && this.#carriageReturnIndex == null) {\n        // skip until we either get a corresponding `\\n`, a new `\\r` or nothing\n        this.#carriageReturnIndex = patternIndex.index;\n        continue;\n      }\n\n      // we got double \\r or \\rtext\\n\n      if (\n        this.#carriageReturnIndex != null &&\n        (patternIndex.index !== this.#carriageReturnIndex + 1 || patternIndex.carriage)\n      ) {\n        lines.push(decodeUTF8(this.#buffer.subarray(0, this.#carriageReturnIndex - 1)));\n        this.#buffer = this.#buffer.subarray(this.#carriageReturnIndex);\n        this.#carriageReturnIndex = null;\n        continue;\n      }\n\n      const endIndex =\n        this.#carriageReturnIndex !== null ? patternIndex.preceding - 1 : patternIndex.preceding;\n\n      const line = decodeUTF8(this.#buffer.subarray(0, endIndex));\n      lines.push(line);\n\n      this.#buffer = this.#buffer.subarray(patternIndex.index);\n      this.#carriageReturnIndex = null;\n    }\n\n    return lines;\n  }\n\n  flush(): string[] {\n    if (!this.#buffer.length) {\n      return [];\n    }\n    return this.decode('\\n');\n  }\n}\n\n/**\n * This function searches the buffer for the end patterns, (\\r or \\n)\n * and returns an object with the index preceding the matched newline and the\n * index after the newline char. `null` is returned if no new line is found.\n *\n * ```ts\n * findNewLineIndex('abc\\ndef') -> { preceding: 2, index: 3 }\n * ```\n */\nfunction findNewlineIndex(\n  buffer: Uint8Array,\n  startIndex: number | null,\n): { preceding: number; index: number; carriage: boolean } | null {\n  const newline = 0x0a; // \\n\n  const carriage = 0x0d; // \\r\n\n  for (let i = startIndex ?? 0; i < buffer.length; i++) {\n    if (buffer[i] === newline) {\n      return { preceding: i, index: i + 1, carriage: false };\n    }\n\n    if (buffer[i] === carriage) {\n      return { preceding: i, index: i + 1, carriage: true };\n    }\n  }\n\n  return null;\n}\n\nexport function findDoubleNewlineIndex(buffer: Uint8Array): number {\n  // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n  // and returns the index right after the first occurrence of any pattern,\n  // or -1 if none of the patterns are found.\n  const newline = 0x0a; // \\n\n  const carriage = 0x0d; // \\r\n\n  for (let i = 0; i < buffer.length - 1; i++) {\n    if (buffer[i] === newline && buffer[i + 1] === newline) {\n      // \\n\\n\n      return i + 2;\n    }\n    if (buffer[i] === carriage && buffer[i + 1] === carriage) {\n      // \\r\\r\n      return i + 2;\n    }\n    if (\n      buffer[i] === carriage &&\n      buffer[i + 1] === newline &&\n      i + 3 < buffer.length &&\n      buffer[i + 2] === carriage &&\n      buffer[i + 3] === newline\n    ) {\n      // \\r\\n\\r\\n\n      return i + 4;\n    }\n  }\n\n  return -1;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}